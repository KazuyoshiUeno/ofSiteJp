






<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>openFrameworks.jp</title>

<!-- syntax highlighting for the documentation -->
<script src="http://openFrameworks.jp/js/shCore.js" type="text/javascript"></script>
<script src="http://openFrameworks.jp/js/shAutoloader.js" type="text/javascript"></script>
<script src="http://openFrameworks.jp/js/shBrushCpp.js" type="text/javascript"></script>
<script src="http://openFrameworks.jp/js/shBrushJava.js" type="text/javascript"></script>
<link href="http://openFrameworks.jp/css/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://openFrameworks.jp/css/shThemeDefault.css" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" href="http://openFrameworks.jp/css/style.css" media="all" />
<link rel="stylesheet" type="text/css" href="http://openFrameworks.jp/css/print.css" media="print" />
<link href='http://fonts.googleapis.com/css?family=Questrial' rel='stylesheet' type='text/css'>
<link rel="search" type="application/opensearchdescription+xml" href="http://openFrameworks.jp/opensearch.xml" title="openFrameworks" />

<link rel="shortcut icon" href="http://openFrameworks.jp/favicon.ico" />
<link rel="icon" href="http://openFrameworks.jp/favicon.ico" type="image/x-icon" />

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript" src="http://openFrameworks.jp/js/jquery.timeago.js" type="text/javascript"></script>

<meta name="google-site-verification" content="RiGtl9pFuFnUeEQ4MU1miiutTR5mmCPUi38YLCn-M-g" />


    <script src="http://openFrameworks.jp/js/jquery.columnizer.min.js"></script>
    <script src="http://openFrameworks.jp/js/documentation.js"></script>
  </head>
  <body>
    <div id="content">
      
  
<div id="head">
  <div class="clearboth"></div>
  <div id="head-left">
    <a href="http://openFrameworks.jp" class="nohover"><img src="http://openFrameworks.jp/images/ofw-logo.png" border="0" alt="openFrameworks" /></a>
  </div>
  <div id="head-right">
    <ul>
      <li><a href="http://openFrameworks.jp/about" class="">about</a></li>
      <li><a href="http://openFrameworks.jp/download" class="" >download</a></li>
      <li><a href="http://openFrameworks.jp/documentation" class="active">documentation</a></li>
      <li><a href="http://openFrameworks.jp/gallery" class="">gallery</a></li>
      <li><a href="http://openFrameworks.jp/community" class="">community</a></li>
    </ul>
    <ul class="menu-externals">
      <li><span class="external-dot"> ></span>&nbsp;<a href="http://forum.openframeworks.cc/index.php" target="_blank">forum</a></li>
      <li><span class="external-dot"> ></span>&nbsp;<a href="http://ofxaddons.com" target="_blank">addons</a></li>
      <li><span class="external-dot"> ></span>&nbsp;<a href="http://wiki.openframeworks.cc/" target="_blank">wiki</a></li>
      <li><span class="external-dot"> ></span>&nbsp;<a href="http://github.com/openframeworks/openFrameworks" target="_blank">github</a></li>
      <li><span class="external-dot"> ></span>&nbsp;<a href="http://openframeworks.cc/list-info" target="_blank">mailing list</a></li>
      <li><span class="external-dot"> ></span>&nbsp;<a href="http://openframeworks.cc/" target="_blank">english site</a></li>
    </ul>
    <div class="clearboth"></div>
    <ul class="menu-externals" style="margin-top:0;padding-top:0">
      <!-- li><span class="external-dot"> ></span>&nbsp;<a href="http://www.bnn.co.jp/books/title_index/web/beyond_interaction_openframewo.html" target="_blank"></a></li -->
      <li><span class="external-dot"> ></span>&nbsp;<a href="/about/aboutjp.html">日本語版について</li>
      <li><span class="external-dot"> ></span>&nbsp;<a href="/forum">日本語フォーラム</a></li>
    </ul>
    <div class="clearboth"></div>
    <!--form method="get" id="searchform" action="/index.php">
	<input type="text" value="" name="s" id="s" class="search_input" /> <input type="submit" value="Search" class="search_button"/>
    </form-->
    <!--form method="post" action="http://scripts.dreamhost.com/add_list.cgi">
        <input type="hidden" name="list" value="list@openframeworks.cc" />
        <input type="hidden" name="domain" value="openframeworks.cc" />
        <input type="hidden" name="url" value="http://openframeworks.cc/list-info/subscribe.html"  />
        <input type="hidden" name="unsuburl" value="http://openframeworks.cc/list-info/unsubscribe.html" />
        <input type="hidden" name="alreadyonurl" value="http://openframeworks.cc/list-info/already.html" />
        <input type="hidden" name="notonurl" value="http://openframeworks.cc/list-info/not.html" />
        <input type="hidden" name="invalidurl" value="http://openframeworks.cc/list-info/invalid.html" />
        <input type="hidden" name="emailconfirmurl" value="http://openframeworks.cc/list-info/confirm.html" />
        <input type="hidden" name="emailit" value="1" />
        name: <input name="name" /> <br />
        email: <input name="email" /><br />
        <span class='but'><input type="submit" name="submit" value="subscribe" /></span> <br/ >
          <span class='but'><input type="submit" name="unsub" value="unsubscribe" /></span>
    </form-->
  </div>
</div><!-- head -->



      <div id="body-wrap">	
	    <div class="page-wide">
            <ul class="submenu">
                <li><a href="/documentation">reference</a></li>
                <li><a href="/tutorials">tutorials</a></li>
            </ul>

            
            <h1>tutorials</h1>    


        	<div class="submenucol-left">
        	    <ul class="categories">
                        <li><a href="/tutorials/introduction">introduction</a></li>
                        <li><a href="/tutorials/firstSteps">firstSteps</a></li>
                        <li><a href="/tutorials/maths">maths</a></li>
                        <li><a href="/tutorials/videos">videos</a></li>
                        <li><a href="/tutorials/developers">developers</a></li>
                </ul>
            </div><!-- End Page Wide -->

        	<div class="submenucol-right">
        	    <h2>ofTutorials - Chapter 1 - 最初の一歩 (翻訳中, under translation)</h2>
        	    <span class="article_meta">2012/02/28&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;<a href="http://www.jeffcrouse.info/">Jeff Crouse</a></span><br/>
        	    <div class="article">
        	    
  <h2>openFrameworksディレクトリ構成</h2>
<p>今このページを閲覧している方々は、http://www.openframeworks.cc/download/ にてopenFrameworksアーカイブファイルをダウンロードし終わり、この適切なセットアップガイドのページにたどり着いているのかと思います。</p>
<p>まず最初にダウンロードしたopenFrameworksのアーカイブファイルを解凍し、解凍後に出来たフォルダを、簡単にアクセス出来る場所に配置する事から行いましょう。　個人的には、下記の様に書類フォルダに配置し、そのショートカットをサイドバーに作成する事が好きです。</p>
<p><img alt="Shortcut" src="images/shortcut.png" /></p>
<p>配置場所に関係なく、フォルダを開くと基本的に下記に示す様なフォルダ構成を見る事が出来るはずです。</p>
<p><img alt="addons, apps, and libs folders" src="images/structure1.png" /></p>
<p>では、これらのフォルダはどんなものなのでしょう？</p>
<h4>addons</h4>
<p>openFrameworks "core"は、最も重要な機能のみを含んでいます。addonsフォルダに追加されるものは、断片的な機能を持ったアプリケーションになります。例えば、XMLファイルを解析するようなものであったり、3Dモデルデータをロードしたり、openCVライブラリを利用したものであったりします。</p>
<h4>apps</h4>
<p>このフォルダが、あなたが作るアプリケーションを配置する場所となります。作業時間のほとんどを費やす場所でもありますね。既に２つのフォルダ… appsフォルダとaddonExamplesフォルダが存在していると思います。</p>
<h4>libs</h4>
<p>oF coreと同レベルでopenFrameworksが使用する全てのライブラリがこのフォルダに含まれています。</p>
<p><strong>注意</strong>：このドキュメントを読んでいれば、CodeForArtフォルダもaddons, apps, libsフォルダと同階層に持つ事になるでしょう。</p>
<h2>サンプルプログラムを試してみよう</h2>
<p>appsフォルダにはexamplesフォルダとaddonsExamplesフォルダの２つのサブフォルダが存在します。両フォルダ内には、openFrameworksが出来る事を説明している、いくつかのopenFrameworksプロジェクトが入っています。まず、アプリケーション開発に入る前に、これら全てのサンプルアプリケーションを動かしてみる事が、よい試みとなるでしょう。ただし使用しているIDEによって、若干動作させる方法が違います。</p>
<h3>XCode</h3>
<p>apps/examples/graphicsExampleフォルダを開き、"graphicsExample.xcodeproj"ファイルをダブルクリックしましょう。</p>
<p><img alt="navigate to graphicsExample" src="images/graphicsExample01.png" /></p>
<p>この様なウィンドウが表示されます。</p>
<p><img alt="graphicsExample 02" src="images/graphicsExample02.png" /></p>
<p><strong>重要：</strong>XCodeのバージョンが何か確認してください。メニューバーから、XCode &gt; About XCodeで確認できます。もし4.0より小さいバージョンですとwindowの見た目がかなり違うと思いますが、慌てる必要はありません。 インターフェース上、対応する機能は、簡単に見つけられるはずです。</p>
<p>大きな"Run"ボタンが左上にあります。XCode3系をお使いの方ですと、"Build &amp; Run"ボタンです。 このボタンを押すと現在選択しているアーカイブターゲットが実行されます。しかし、デフォルトではアクティブターゲットが"openFrameworks"となっていると思います。このまま"Run"ボタンを押しても何も行われません。　今、実行したいプログラムは"graphicsExample"なので、もし以下の様に"openFrameworks"が選択されていたら、</p>
<p><img alt="openFrameworks library chosen" src="images/target-bad.png" /></p>
<p>"openFrameworks"の部分をクリックして"graphicsExample"を選択しましょう。下記の様になると思います。</p>
<p><img alt="graphicsExample target chosen" src="images/target-good.png" /></p>
<p>では、"Run"ボタンをクリックしましょう！この様に表示されるはずです。</p>
<p><img alt="graphicsExample, running" src="images/graphicsExample03.png" /></p>
<p>エスケープキー　もしくは、Apple+Qでプログラムが終了します。</p>
<p><strong>注意：トラブルシューティング</strong></p>
<p>もしエラーが発生したら、"Base SDK"の設定を10.6にしましょう。</p>
<ul>
<li>左端にある"graphicsExample"をクリック</li>
<li>“Build Settings”をクリック　- 下記参照</li>
<li>"All"と"Combined"を選択しておきましょう。</li>
<li><em>Base SDK</em> を選択して、10.6に設定しましょう。</li>
</ul>
<p><img alt="10.6 Fix" src="images/tenpointsix.png" /></p>
<h5>プロジェクト毎にこの設定を行う可能性があるので、慣れておく事をお勧めします。</h5>
<p>では、全てのサンプルプログラムを試してみましょう。</p>
<h3>Code::Blocks</h3>
<p>coming soon!</p>
<h3>Visual Studio</h3>
<p>coming soon!</p>
<h2>初めてのプロジェクト作成</h2>
<p>冒頭で述べたように、openFrameworksは、うんざりするようなC++プロジェクトをセットアップする事に関しては必要ありません。しかしながらFlashやProcessingの様に、プロジェクトの作成方法として、"ファイル" &gt; "新規作成"というようなものが存在しません。代わりにexampleプロジェクトをコピーする事で賄っています。</p>
<p><strong>重要：</strong>
上記をふまえると、exampleプロジェクトを修正したりexpampleフォルダ内にあなたの作ったアプリケーションを配置するべきではないという事を意図しています。exampleプロジェクトは、あなた自身がこれから作ろうとするアプリケーションのスタートポイントとして配置（存在）されています。何か新しいプロジェクトを作成する時のスタートポイントとして維持しておいた方がよいでしょう。この大切さは、openFrameworksの理解が進むにつれ分かってくると思います。</p>
<p>初心者の多くにとっては、これらは見た目よりも、大きな障害になる可能性がありますので、まず最初にいくつか用語を決めて、説明していきます。</p>
<p>appsフォルダを開くと、 <em>examples</em> と <em>addonsExamples</em> フォルダが存在しています。
これらを<em>ワークスペース</em>と呼ぶ事にしましょう。</p>
<p>ワークスペースの一つを開いてみると、その中に幾つかのフォルダ… <em>easyCamExample</em>, <em>floatingPointImageExample</em>, <em>movieGrabberExample</em>, <em>serialExample</em> などがあります。これらの１つ１つが<em>プロジェクト</em>になります。各プロジェクトは、".xcodeproj"ファイルと"src"フォルダを含んでいます。<em>プロジェクト</em>は、<em>ワークスペース</em>内に存在していないといけません。そして１つのアプリケーションとしてコンパイルされます。</p>
<p><img alt="Workspace terminology" src="images/workspace04.png" /></p>
<p>各<em>プロジェクト</em>を作るにあたり、各プロジェクトは<em>ワークスペース</em>内に配置しなければなりません。そして、<em>examples</em>と<em>addonsExamples</em>ワークスペース内には、他にあなたが独自に作成したものを配置する事を推奨しません。
という事をふまえ、まずは、新しい<em>ワークスペース</em>を作ってみましょう。単に“MyFirstWorkspace”というフォルダをappsフォルダ内に作成してください。openFrameworksを使って行くうちに、多くのワークスペースを作成することになるとおもいますが、"apps"フォルダ直下に置かなければいけないという事が重要です。言い換えれば、あるワークスペースは、他のワークスペース内に配置する事は出来ないという事です。</p>
<p><img alt="&quot;My First Workspace&quot;" src="images/workspace01.png" /></p>
<p>次に、"emptyExample"フォルダを"examples"ワークスペースから"MyFirstWorkspace"フォルダへコピー（移動ではないですよ！）しましょう。Macをお使いの方でしたら、文字通りemptyExampleフォルダをクリックして選択し、コマンド＋Cでコピーし、“MyFirstWorkspace”フォルダに移動して、コマンド+Vでペーストになります。結果、次の様になっていると思います。</p>
<p><img alt="My First Project" src="images/workspace02.png" /></p>
<p>次に、コピーした"emptyExample"フォルダ名を"MyFirstProject"とリネームしましょう。</p>
<p><img alt="My First Project" src="images/workspace03.png" /></p>
<p>ここで一番重要な事は、XCodeプロジェクトファイルが、Rootフォルダ（色のついた上記の図を参照ください）から、<em>丁度</em>３つ下ったところに配置されている事です。新しいプロジェクトを作成した時に、明白な理由がないにも関わらず、もし何千ものエラーが出た場合は、XCodeプロジェクトファイルが正しい位置に配置されているかどうかを確認してください。</p>
<p>この理由は'lib'フォルダと関係しています。以前、openFrameworksは沢山のライブラリ群の"糊"であり、それらのライブラリ群は'lib'ディレクトリに配置されていますと説明しました。</p>
<p>またいろいろなライブラリ群を見つけてリンクをするのはIDEの仕事という事も、知りました。そのため、IDEがあなたのプログラムをコンパイルしようとする時、"../../../lib"内からライブラリ群を探す様にセットアップされたり、また、別の言い方をすると、「フォルダを３つ戻ってlibフォルダを探す(http://support.dtsearch.com/webhelp/dtsearch/relative_paths.htm[relative] to your .xcodeproj)」とも言えます。</p>
<p>例えば、もしopenFrameworksプロジェクトの設定を深く掘った場合は、"../../../libs/FreeImage/include" や "../../../libs/poco/include"の様にして見つける事になるでしょう。</p>
<p>.xcodeprojファイルがof_preRelease_v007_osx/apps/[workspace]/[project]内にある限りは、全てコンパイルされるでしょうが、そうでなければ、コンパイル結果は醜いものとなるでしょう。</p>
<p>では、これで、あなたの最初のopenFrameworksプロジェクトが出来ました。"MyFirstProject"内のXCodeプロジェクトファイルをダブルクリックし、"emptyExample"がターゲットとして選択されている事を確認したら、"Run"ボタンをクリックしてみましょう。　</p>
<p><img alt="My First Project" src="images/PlainGray.png" /></p>
<p>なにもない！ですね。でも、これで大丈夫です。今のところ、エキサイティングなものではないのですが、これは正常な結果なのです。</p>
<p>エスケープキーまたはコマンド+Qでプログラムを終了できます。</p>
<h3>プロジェクト名の変更（XCode）</h3>
<p>"emptyExample.xcodeproj"ファイル名を"MyFirstProject.xcodeproj"に変更したいと思うでしょう。もし使用しているXCodeのバージョンが4より小さい場合は可能ですが、XCode 4を使用している場合は、いくつか問題が生じます。
XCode4を使用している場合は、XCodeでプロジェクトを開き、左上にある"emptyExample"をクリックし選択します。</p>
<p><img alt="Renaming your Project" src="images/rename01.png" /></p>
<p>リネームすると、下記の様なダイアログボックスが表示されますので、"Rename"ボタンをクリックしましょう。</p>
<p><img alt="Renaming your Project" src="images/rename02.png" /></p>
<h3>完成!</h3>
<p>XCodeの"Run"ボタンをクリックすると、プログラムコードがコンパイルされ実行可能ファイルが“bin”ディレクトリ内に配置されます。この実行可能ファイルをダブルクリックすることで、アプリケーションが実行されます。
"MyFirstWorkspace/MyFirstApplication/bin"フォルダを見てみると、アプリケーションアイコンが見つかるはずです。
それが、あなたのアプリケーションです！　それをダブルクリックすると、先ほどと同様なグレーウィンドウが表示されると思います。これで、このアプリケーションをMacユーザの友達に送る事が出来ますし、友人達はその素晴らしいグレーウィンドウアプリケーションを実行する事が出来ます。</p>
<p><img alt="Your Executable" src="images/workspace05.png" /></p>
<h2>プログラムコードを書く</h2>
<p>では、プロジェクト作成方法は理解出来たと思いますので、いくつかコードを書く事を始めてみましょう。これからのセクションではopenFrameworksアプリケーションの構造、単純な描画およびsetup関数の紹介になります。</p>
<h3>testApp.cpp</h3>
<p>遂に！、プログラムコードを見て行くところまできました！まず最初に、プロジェクトファイルをXCodeで開く必要がありますね。先ほどのセクションで作成した、"MyFirstWorkspace"ワークスペース内の"MyFirstProject"で作成していきましょう。プロジェクトファイルを開いたら、XCodeの一番左側にある<em>ナビゲーションビュー</em>に目を移動し、以下の様に、三角マークをクリックして開きましょう。</p>
<p><img alt="Open up the project" src="images/expand01.gif" /></p>
<ul>
<li>"MyFirstProject"の横にある三角マークをクリック</li>
<li>"src"の横にある三角マークをクリック</li>
<li>testApp.cppをクリック</li>
</ul>
<p>testApp.cpp は、これからのチュートリアルを行ううちに、一番見慣れていくものになるでしょう。 <em>エディターウィンドウ</em>内で、以下の様になっているはずです。</p>
<pre><code class="cpp">#include &quot;testApp.h&quot;

//--------------------------------------------------------------
void testApp::setup(){

}

//--------------------------------------------------------------
void testApp::update(){

}

//--------------------------------------------------------------
void testApp::draw(){

}

//--------------------------------------------------------------
void testApp::keyPressed(int key){

}
</code></pre>

<p>それでは、ここで何が行われいるのか見て行きましょう。</p>
<p>testApp.cppは、イントロダクションで既に書いたファイルですが、
いろんな意味でhello.cppの様なものです。</p>
<p>そして単なるc++ソースコードを含んだテキストファイルです。
IDEを使用して編集することによって、コードを理解することを楽にしてくれる
シンタックスハイライトが反映されていたり、コンパイルやプログラムを実行する時にも、
簡単になります。</p>
<p>まず基本的なことですが、からっぽな関数群が見えていると思います。</p>
<p>ウィキペディアでは（http://en.wikipedia.org/wiki/Function_(computer_science)[function]）、
大きなプログラムの一部を構成するものと説明されています。</p>
<p>上記はコードの一部ですが、４つの関数〜setup, update, draw, keyPressed〜があります。
各々の関数は、１つの中括弧（{}）が付いています。通常、これらの中括弧内に書かれたものが、その関数を作ります。
（値の定義、繰り返し、その他の関数呼び出しなど）</p>
<p>イントロダクションのQ&amp;Aにある「ソフトウェアフレームワークとは？」でお話した、
映画制作会社の説明が、類似していて、理解しやすいと思います。</p>
<p>openFrameworksがその基本的基盤や論理的な詳細を
どの様にして提供しているか？がtestApp.cppに書かれているものになります。</p>
<p>これらの関数は、あなたのプログラム実行中に、
それぞれ違ったタイミングでopenFrameworksによって呼び出されます。</p>
<p>それでは、いくつかの関数を見ていきましょう。</p>
<h4>setup</h4>
<p>この関数は、アプリケーションライフサイクルの１番最初（ウィンドウがオープンされる前）に呼び出されるものです。
たとえば、ウィンドウサイズをセットしたい場合を考えると、ウィンドウが実際に開かれる（表示される）よりも前に行いたいですよね？その様な用途ととして、このsetup関数は適切なものになると思います。</p>
<h4>update, draw</h4>
<p>setup関数が実行された後、update関数とdraw関数はアプリケーションが終了するまでループします。つまり、setup()関数が実行された後、update()関数が実行されdraw()関数が実行され…update()関数ー＞draw()関数という様になります。これらの処理は基本的にはコンピュータが対応出来る範囲の速度で実行されます。
典型的にupdate()関数は、プログラムの状態をアップデートする為に使用され（例えば、変数値の変更）、その一方draw()関数でウィンドウ内で実際に描画を行う為に使用します。</p>
<h4>keyPressed, keyReleased, mouseMoved, mouseDragged, mousePressed</h4>
<p>上述した３つの関数とは違い、これらの関数は、ユーザが何かを行った時にのみ呼び出されます。想像できますか？
説明は、ここまでにして、実際にコードを見てみましょう。</p>
<h3>Making a Mark</h3>
<p>ofCircle関数を使用して、灰色のウィンドウ内にシンプルな円を描画してみる事からスタートしてみようと思います。
draw()関数内に<code>ofCircle(200, 200, 60);</code> と入力してください。以下の様になります。</p>
<pre><code class="cpp">void testApp::draw(){
    ofCircle(200, 300, 60);
}
</code></pre>

<p><strong>注意</strong>：各行の最後にセミコロンが存在している事に注意してください。すべての関数呼び出しはセミコロンで終わる必要があります。また、関数名はセンシティブです。OfSetColor, OFsetcolorとタイプしても実行されません。ofSetColorとタイプする必要があります。</p>
<p>では、プログラムを実行してください。以下の様に表示されるはずです。</p>
<p><img alt="A Plain White Circle" src="images/MyFirstProject01.png" />
おめでとう！ 今、あなたはスクリーン上に“何か”を表示できました！これからは、全て楽になっていきいますよ。
でも、私たちは何を今行ったのでしょう？</p>
<p><a href="http://openframeworks.jp/documentation/graphics/ofGraphics.html#ofCircle">ofCircle</a>は、openFrameworksで定義された関数です（それ故、'of'というプレフィックスが付いているのです）。
ofCircleは、好きなだけdraw関数内で呼び出す事が可能です。ofCircleに続く括弧内の数字はパラメータと呼ばれています。http://en.wikipedia.org/wiki/Parameter_(computer_programming)[arguments].
これらの値が、関数が何を行うのかを正確に示しています。
「円を描きたい。でも何処に？どのくらいの大きさで？」という疑問の答えになっているということです。</p>
<p>関数は幾つもの値を持つ事ができます。これらの値は、カンマで区切られています。ofCircleは３つの値を受け取ります。
x座標、y座標そして半径の３つです。</p>
<p>これらの値について理解する為に必要な事がいくつかあります。</p>
<ul>
<li>openFrameworks使用される寸法値はピクセル単位です。先ほど作成した円の半径は60となっていますが、これは円内にトーラルPI*60^2^ピクセル数存在している事を意味しています。</li>
<li>これは明確な感じがしますが、座標値（x,y）は円の中心を示しています。他のシェイプ（例えば四角形）は、左上を起点としています。</li>
<li>座標系の起点はウィンドウの左上となっています。その為に、私たちが作った円は、左端から200ピクセル、上から300ピクセルの位置に表示されます。</li>
</ul>
<p><strong>注意</strong>：パラメータの順番は重要です。ofCircleの最初の値は、いつも"x座標"を意味しますし、３番目の値はいつも"半径"を意味します。</p>
<p><strong>注意</strong>：パラメータを１つも持たない関数が存在しますが、括弧は必要です。（例：ofFill:http://www.openframeworks.cc/documentation/graphics/ofGraphics.html#ofFill[ofFill]）</p>
<p>もしかするとofCircleについての情報をhttp://www.openframeworks.cc/documentation/[openFrameworks documentation page]で得ているかもしれません。この[openFrameworks documentation page]は、これから参照する事が多くなると思います。</p>
<h3>色を追加する</h3>
<p>円を描画しましたが、少々つまらないので色について考えてみましょう。それには、ofSetColor：http://www.openframeworks.cc/documentation/graphics/ofGraphics.html#ofSetColor[ofSetColor]が必要になります。<code>ofSetColor(255, 0, 255);</code>をofCircleの直前に追加してみてください。以下の様なコードになります。</p>
<pre><code class="cpp">void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(200, 300, 60);
}
</code></pre>

<p>では、アプリケーションを実行してみてください。
<img alt="A Plain White Circle" src="images/MyFirstProject02.png" /></p>
<p>ofCircleと同じく、ofSetColorも３つの値を必要としています。ただ、値の意味は全く違います。ドキュメントページ：http://www.openframeworks.cc/documentation/graphics/ofGraphics.html#ofSetColor[ofSetColor]を見てみると、パラメータ値が赤、緑、青を示している事に気づくと思います。これらの値は、それぞれ0〜255の範囲になっています。例えば、<code>ofSetColor(255, 0, 255);</code>というのは、「赤100%, 緑0%, 青100%」の色で、全てのを描画する」という事になります。</p>
<p>TIP: 値を変更して色が変化するのを試してみましょう。</p>
<p>もう１点、重要な事があります。ofSetColorを呼びだす事は、クレヨンを箱の中から選んでいるのと同じ様な事です。
ofSetColorをコールした後に描かれるものは、再度ofSetColorをコールするまで、色は変更されません。また、他の円を描画したい場合は、下のコードの様に、単にofCircoleを再びコールすれば可能です。</p>
<pre><code class="cpp">void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(200, 300, 60);

    ofCircle(500, 500, 100);
}
</code></pre>

<p>しかし、違う色で円を描画したい場合は、ofSetColorを再びコールする必要があります。</p>
<pre><code class="cpp">void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(200, 300, 60);

    ofSetColor(0, 255, 255);
    ofCircle(500, 500, 100);
}
</code></pre>

<p><img alt="Two Colorful Circles" src="images/MyFirstProject03.png" /></p>
<p>使用できる図形
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>openFrameworksは、もちろん円以外のものも描画できます。</p>
<p>. 四角形：引数（x, y, width, height）
　http://www.openframeworks.cc/documentation/graphics/ofGraphics.html#ofRect[ofRect]</p>
<p>. 三角形：引数（x1, y1, x2, y2, x3, y3) 
　http://www.openframeworks.cc/documentation/graphics/ofGraphics.html#ofTriangle[ofTriangle]</p>
<p>. 線：引数(x1, y1, x2, y2)
　http://www.openframeworks.cc/documentation/graphics/ofGraphics.html#ofLine[ofLine]</p>
<p>. 楕円：引数(x, y, width, height)
　http://www.openframeworks.cc/documentation/graphics/ofGraphics.html#ofEllipse[ofEllipse]</p>
<p>. カーブ：引数(x0, y0, x1, y1, x2, y2, x3, y3)
　http://www.openframeworks.cc/documentation/graphics/ofGraphics.html#ofCurve[ofCurve]
　（x1,y1）から（x2, y2）へカーブを描画します。カーブはコントロールポイントである(x0, y0)と(x3, y3)によって形状が影響を受けます。</p>
<p><strong>注意</strong>：コントロールポイントはトリッキーです。photoshopやillustratorを使用した事のある人であれば理解できるでしょう。もし使用した事がない人は、http://www.actionscript.org/resources/articles/172/1/Understanding-curves-and-control-point-placement/Page1.html[this tutorial].をチェックしてみてください。こちらはアクションスクリプトで書かれていますが、カーブとコントロールポイントについてのコンセプトについて詳しい説明が掲載されています。</p>
<p>TIP: “MyFirstWorkspace”ワークスペース内に３つのプロジェクトを作成し、それぞれで、違う「形」を、いろいろな色や場所に描画してみましょう。</p>
<h3>動きを加える</h3>
<p>静的な図形を描く事も面白いですが、その図形をスクリーン上で動かしてみる事はどうでしょう？</p>
<p>draw()関数は上述した様に、プログラム実行後、繰り返し呼ばれます。openFrameworksがアニメーションを表現する方法に直結している事な為、とても重要です。Flash等の"ステージ"に何かオブジェクトを置いて必要な時に位置を変更する様なアプリケーションを使用しているユーザにとっては、少々直感的でないかもしれません。</p>
<p>openFrameworks（もしくは、ほとんどのコンピュータアニメーション）での仕組みは違います。openFrameworksは、よりトラディショナル（私たちは保守的なディズニー/バンビを話しています。）なアニメーションです。毎フレーム時、全てのフレームを再描画する必要があるのです。</p>
<p>openFrameworksでは毎回draw()関数が実行される時が"１フレーム"となります。上記のプログラムを実行すると紫色の円が描画されますが、実際は「円が描画され、そしてクリアされる」という事を１フレームとして繰り返し実行されています。ただ、非常に高速に繰り返されているので、ただ表示されている様に見えているのです。</p>
<p>上記のサンプルでは、円を描画する時にウィンドウ内のどこに円を描くかをofCircle関数に伝えるために２つの数値を使いました。したがって円を動かしたい場合は、これらの数値を時間とともに変更していく必要があります。たぶん、最初の描画時が、(200, 300)の位置であったとすれば、次は１ピクセル右に…(201, 300)、そして、もう１ピクセル右へ(202, 300)という感じで。</p>
<p><code>c++</code>で、普段プログラミングを行う時、値を変更したい場合はいつも変数を宣言（作成）します。変数は、その時々で異なる形と大きさを持ちます。10進数、整数、文字、または文字列などです。今回はofCircle関数において座標を表現する為に２つの<em>int</em> 型を使用してみましょう。</p>
<p>下記の様な２行をtestApp.cppの一番上にある<code>#include“</code>の真下に書いてください。</p>
<pre><code class="cpp">#include &quot;testApp.h&quot;

int myCircleX;
int myCircleY;
</code></pre>

<p>これで２つの変数を"宣言"した事になります。１つは'myCircleX'で、もう１つは、'myCircleY'ですね。実際、あなたが好きな名前で宣言する事も出来ますが、変数名を決める時は、それがどのように使用されるか？どんなものに関連しているか？を考えて決める方が良い方法です。
また、これらの変数は整数値を保存する為にも使用します。
変数を宣言する事は重要で且つ必要なステップです。「よし！、変更できる数値を保存する事が必要だ！」</p>
<p>次に必要な事は、これらの変数に初期値を与える事です。ここでの最終的に行う事は、これらの変数値を時間とともに変更する事です。ただし値を変更する前に変数に初期値を与えておく必要があります。これは上記で作成した円を動かす前に、最初に何処に表示するか？という事になります。</p>
<p>前章でsetup()関数はアプリケーションが起動した時に１度だけ呼び出され、２度と呼び出されないと学びました。初期値を設定する関数としてsetup()関数が役に立つようなので、次のコードを加えてください。</p>
<pre><code class="cpp">void testApp::setup(){
    myCircleX = 300;
    myCircleY = 200;
}
</code></pre>

<p>これでOKです！ 簡単に説明すると、２つの変数'myCircleX'と'myCircleY'を「初期化」もしくは「初期値を代入」した事になります。数学方程式の様に、300という値を'myCircleX'へ割り当てるためにイコール文字 '='を使います。<code>c++</code>では、イコール'='は、値を代入する為に使われているため、"代入演算子"として知られています。"演算子"は、いつも右から左へ流れます。代入される値は右辺に配置し、右辺に配置された値を受ける変数は左辺に配置します。</p>
<p>それでは、ofCircle関数を少々編集してみましょう。：</p>
<pre><code class="cpp">void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, 60);
}
</code></pre>

<p>３つの変数をofCircle関数に与えている事自体はかわっていませんが、(200, 300)と"ハードコーディング"していた為に変更できなかったものが変更可能な変数になりました。</p>
<p>この状態でアプリケーションを起動したとしても、何も変化していません。まだ何も値を変更する事を行っていない為です。
では、下記の様にdraw()関数を少々変更してみてください。</p>
<pre><code class="cpp">void testApp::draw(){
    myCircleX = myCircleX + 1;

    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, 60);
}
</code></pre>

<p>追加した新しい行で、setup()関数内で使用しているのと同じ様に、再び“代入演算子”を使用しています。この追加した行を言葉で説明すると「myCircleXに１を加え、その値をmyCircleXに代入せよ」となります。別の言い方をすると、「私たちが
myCircleXを増加させている」と言えます。<code>c++</code>は、値を増加させるための共通ショートカットとして<code>myCircleX++;</code>という表現を割り当てる事が出来るようになっています。これは非常によく使われる共通なものです。では、このショートカットを使って、コードを書き換えてみましょう。</p>
<p>myCircleX = myCircleX + 1;
は、
myCircleX++;
となります。</p>
<p>アプリケーションを動かしてみてください。円が画面の右の方へ動いているはずです！</p>
<p>より魅力的な動きにする前にもう１つ必要な事があります。update()関数とdraw()関数についての説明を再度読んでみると、draw()関数は、描画する為（今のところ、十分なのですが）という事に気づくと思います。しかしupdate()関数は、変数を更新する関数である事にも気づくと思います。この理由については後述致しますが、追加した新しい行を、update()関数に移動してみましょう。</p>
<pre><code class="cpp">void testApp::update(){
    myCircleX++;
}

void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, 60);
}
</code></pre>

<p>機能的な観点で違いを理解しなくとも、この習慣に慣れる事は良いことです。</p>
<h3>フレームレート</h3>
<p>「円の動き」について、最初はある意味スローだったスピードが速くなる事に気づく事があるかもしれません。アプリケーションが起動した直後はスロースピードであったのに、すごく速くなってしまう…これはアプリケーションのフレームレートに因るものです。既にお話してはいますが、フレームレートはdraw()関数／update()関数ループ処理の速度を示します。</p>
<p>下記の１行をdraw()関数の最後に挿入してみてください。アプリケーションウィンドウの左上にフレームレート値を見る事が出来るようになります。</p>
<pre><code class="cpp">ofDrawBitmapString(ofToString(ofGetFrameRate())+&quot;fps&quot;, 10, 15);
</code></pre>

<p>1000fpsに近い値になるかと思います。1秒間に約1000回、円が描画されているという事です。もし他のアプリケーションを沢山起動し、FinalCutで巨大なビデオのレンダリングを始めたとすると、フレームレート値が落ちていることに気付く事になるでしょう。アプリケーションは、単純にコンピュータが実行できる可能な速さで動こうとします。</p>
<p>スムーズに動かし、そしてより予測可能な観点として、フレームレートを適正な値…60くらいにセットしてみましょう。
その為に、setup()関数に、以下の１行を配置しましょう。</p>
<pre><code class="cpp">void testApp::setup(){
    ofSetFrameRate(60);

    myCircleX = 300;
    myCircleY = 200;
}
</code></pre>

<p>プログラムを起動してみてください。大分、円の動くスピートが遅くなったと思います。
上記で追加した関数は、「１秒間に60フレーム」という事を必ずしも保証しませんが、最低60フレームという事は保証されます。すごく古いコンピュータを使用している、もしくは他のプログラムによってプロセッサに極めて負荷がかかっていなければ、円を動かすようなシンプルな事に対しては、一貫して60fpsで動作するのに問題は起こりません。</p>
<p><strong>[TIP]</strong> 毎秒60回update()関数が実行される毎に、円のx座標を1ピクセル増やしていますが、240ピクセル円を動かすには、何秒必要か考えてみてください。</p>
<p><strong>[TIP]</strong> 動きが遅い！
フレームレートをコントロール出来るようになりましたが、60ピクセル／秒では、とても遅く思われるかもしれません。これを解消するにはフレームレート値を増やす方法がありますが、60fpsは非常に良い値なので、代りに円自身の動くスピードを変更してみましょう。毎1ピクセル増やしているところを、4ピクセルに変更してみます。ショートカットを使用してupdate()関数を以下の様に変更しましょう。</p>
<pre><code class="cpp">void testApp::update(){
    myCircleX+=4;
}
</code></pre>

<h3>パックマン エフェクト</h3>
<p>それでは、「紫の円」に最後のエフェクトを付けてみましょう。ここまでで作成してきたアプリケーションでは、単に円がスクリーンの右へ移動し、結果的にスクリーンから消えてしまいます。そこで「スクリーン右側へ到達したら、スクリーン左側から再度出現させる」という修正を行ってみましょう。ちなみに、ここでは、これを<strong>パックマン　エフェクト</strong>と呼びます。</p>
<p>コードを修正する前に、今のコード内に存在する変数という観点について考えてみましょう。現状、"myCircleX"は円のx座標を表現しており、毎フレームで1ピクセル（上述のtipを反映していれば4ピクセル）づつ増加しています。openFrameworksのデフォルトウィンドウサイズは1024x768ピクセルなのでパックマンエフェクトを実現する１つの方法としては、"myCircleX"が1024を超えたら、300にリセットする事で可能です。</p>
<p>では、どの様にすれば良いでしょうか？変数値を更新するには、update()関数で行うべき事を私たちは既に学んでいますね。
そして、<strong>もし</strong> 「“myCircleX”が1024より大きくなったら300に値をリセットする」としたい為、<strong>if</strong> 構文を使用します。</p>
<pre><code class="cpp">void testApp::update(){
    myCircleX++;        
    if(myCircleX &gt; 1024) 
    {
        myCircleX = 300;
    }
}
</code></pre>

<p>このコードを説明すると、</p>
<ul>
<li>myCircleX を１増加します。</li>
<li>myCircleXが1024を超えているか？テスト（確認）します。</li>
<li>テスト結果が<strong>真</strong>の場合のみ、myCircleXを300にセットします。</li>
</ul>
<h2>インタラクション（相互作用）の追加</h2>
<p>アニメーションについては、マスターしました！　では次に、ユーザの行動を取り込んでみましょう。このセクションではキーボードとマウスのインタラクションに注目してみます。</p>
<p>これまで、setup()、update()、draw()の３つの関数について見てきました。インタラクションを追加するにあたり、testApp.cpp内の以下２つの関数について見て行きます。</p>
<pre><code class="cpp">void testApp::keyPressed(int key){

}

void testApp::keyReleased(int key){

}
</code></pre>

<p>openFrameworksはユーザがキーボードを使用して何かを行った時に作成したアプリケーションにそれを知らせる為の仕組みを既に持っています。あなたが行うべき事はイベントが起きた時に実行させたい関数を用意する事のみです。</p>
<ul>
<li>ユーザーが物理的にキーを押した</li>
<li>ユーザが物理的に押していたキーを離した</li>
</ul>
<p>もし、あなたが「文字をタイプする」という事に対して、それは１つのアクションだと普段から考えている場合は、少々分かり難らいかもしれません。「私は、"O"という文字をタイプした！」という感じです。しかし、本来は２つのアクション（もしくは"イベント"）で構成されています。この違いについては簡単に理解する事になると思います。</p>
<p>"KeyboardInteraction"プロジェクトを“MyFirstWorkspace”ワークスペース内に作成します。もし作成方法を忘れていたら、“初めてのプロジェクト作成”に戻ってください。</p>
<p><img alt="Keyboard Interaction Project" src="images/KeyboardInteraction01.png" /></p>
<h3>coutコマンド</h3>
<p>これらの関数が、どの様に動いているかを確認する為の一番速い方法はコンソールにメッセージを表示する事です。コンソールに"Hello, World!"と表示した事を覚えていますか？ <code>c++</code>の関数である<a href="http://www.cplusplus.com/reference/iostream/cout/[&quot;cout&quot;]">cout</a>を使用しました。(c out と発音します。)
このcoutの構文が関数と同じ様なものでないので、使用する時に少々奇妙に感じるかもしれません(coutコマンドは、実際にはオブジェクトですが、これについては別の章で説明します)。　しかしデバッグするには、非常に便利なコマンドです。</p>
<p>プログラムが出力したテキストの確認についてですが、XCodeはそれを閲覧できるウィンドウを備えています。<a href="http://www.cplusplus.com/reference/clibrary/cstdio/stdout/[stdout]">stdout</a>
View-&gt;Debug Area-&gt;Activate Consoleもしくは、apple+shift+Cを押してみましょう。</p>
<p><img alt="Activate Console" src="images/activate-console.png" /></p>
<p><strong>注意</strong>
XCode3を使用している方。Shift-Cmd-Rを使用してください。もしくはXCode設定で、Xcode-&gt;Preferences-&gt;Dubuggingの画面で、Start Show Consoleをオンにしましょう。</p>
<p>XCodeの下方に下記の様なパネルが表示されます。
<img alt="Debug Area" src="images/debug-area.png" /></p>
<p>では下記の様に２つのキー関数にコードを追加し、コンソールに表示してみましょう。</p>
<pre><code class="cpp">void testApp::keyPressed(int key){
    cout &lt;&lt; &quot;keyPressed &quot; &lt;&lt; key &lt;&lt; endl;
}

void testApp::keyReleased(int key){
    cout &lt;&lt; &quot;keyReleased &quot; &lt;&lt; key &lt;&lt; endl;
}
</code></pre>

<p>上述した様に、cout関数の構文は、この章においては、少々奇妙に感じられると思います。<code>c++</code>では、coutは"標準出力ストリーム"と表現されています。“ストリーム”の意味については、特に気にする必要はありませんが、'keyPressed'内で使用しているcoutの行を見ると、coutが扱っているデータの"流れ"が存在していると見る事が出来ます。最初に、"keyPressed"という文字列を"流れ"に送り、そしてkey変数を送っています。最後に、<a href="http://www.cplusplus.com/reference/iostream/manipulators/endl/[endl]">endl</a>を呼び出しています。</p>
<p>'key'変数は、押された／離された「キー」を表しています。
それでは、アプリケーションを起動して、キーをタイプしてみましょう。試しに、“qwerty”とタイプしてみるとコンソール上では下記の様に表示されると思います。</p>
<pre><code class="cpp">GNU gdb 6.3.50-20050815 (Apple version gdb-1708) (Thu Nov  3 21:59:02 UTC 2011)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &quot;show copying&quot; to see the conditions.
There is absolutely no warranty for GDB. Type &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-apple-darwin&quot;.tty /dev/ttys002
[Switching to process 92317 thread 0x0]
keyPressed 113
keyReleased 113
keyPressed 119
keyReleased 119
keyPressed 101
keyReleased 101
keyPressed 114
keyReleased 114
keyPressed 116
keyReleased 116
keyPressed 121
keyReleased 121
</code></pre>

<p>前半部分の数行については、気にしないでください。デバッガによって追加されたものです。</p>
<p>'key'変数によって供給されているものは、実際には'int'型の値となっています。もしかしたら、あなたはstringもしくはchar型を想像したのではないでしょうか。実は、このint型の番号は、押されたキーの<a href="http://www.asciitable.com/[ASCII code]">ASCII</a>コードを示しています。</p>
<p><img alt="ASCII Table" src="images/ascii_table.jpg" /></p>
<p>キーボード上で見る事が出来るものが赤色の列にあります。"Dec"列（10進数）にある番号は、key関数で取得する番号が書かれています。</p>
<p><strong>[TIP]</strong>
<a href="http://www.cplusplus.com/doc/tutorial/typecasting/[type casting]">type casting</a>という方法でint型からchar型あるいは文字に変換する事が可能です。"（char）"をkey変数の直前に置きます。</p>
<pre><code class="cpp">cout &lt;&lt; &quot;keyPressed &quot; &lt;&lt; (char)key &lt;&lt; endl;
</code></pre>

<p>type casting については後述します。</p>
<p>コンソールに表示する事までは出来ましたが、キーを押す事によるインタラクションについて、もう少し進めてみたいと思います。</p>
<p>「動きを加える」で行った様に、testAppに２つの変数を追加し円を描画する事から始めます。</p>
<pre><code class="cpp">#include &quot;testApp.h&quot;

int myCircleX;
int myCircleY;

void testApp::setup(){
    myCircleX = 300;
    myCircleY = 200;
}

void testApp::update(){

}

void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, 60);
}
</code></pre>

<p>「動きを加える」のところで、変数を利用する事で円そのものを動かしました。これから行う事との違いは、ボールの動きをキーボードの入力によって作るところです。毎フレームごとに自動的に変数値を増加していたところをキーの入力によって変更する必要があるということです。具体的にはupdate()関数で更新する代りに、mousePressed()関数内（もしくはmouseReleased()関数でも良いでしょう）で、myCircleXとmyCircleY変数値を変更する必要があります。</p>
<p>それでは、典型的なゲームのキー・スキームに習って、「wを押した時は上へ」「aを押した時は左へ」「sを押した時は右へ」「dを押した時は下へ」動くようにしてみましょう。
ASCIIコード値表を参照してみると、それぞれの文字が119, 97, 115, 100の値である事がわかります。次に、どの値が「上」「下」「左」「右」であるのかについて考え、変数myCircleXとmyCircleYをどの様に変更していけば良いか？と考えてみると、以下の様なコードになります。</p>
<pre><code class="cpp">void testApp::keyPressed(int key){
    if(key==119) // 'w' key
    {
        myCircleY--;
    }
    if(key==97) // 'a' key
    {
        myCircleX--;
    }
}
</code></pre>

<p>上記で分かる通り、キーを押した時にkeyPressed()関数が呼び出されます。そして、どのキーが押されたのかを判断したいので<a href="http://www.cprogramming.com/tutorial/lesson2.html">if構文</a>を使用しています。ここではkeyPressed関数が呼ばれた時、最初に押されたキーのASCIIコードが119なのかをテストしています。</p>
<p><strong>注意</strong>
ダブルイコールは、サインです。「代入」というよりもむしろ、「比較」を意味しています。119という数字を代入するのではなく、変数keyが119なのかどうかをテストするためにダブルイコールを使用します。結果がtrue（真）であれば、その直後の中括弧内のコードが実行されます。</p>
<p>sキーとdキーについての処理も追加してみてください。</p>
<p><strong>[TIP]</strong>
以下のコードも同様に動作します。</p>
<pre><code class="cpp">if(key=='w')
{
    myCircleY--;
}
if(key=='a')
{
    myCircleX--;
}
</code></pre>

<h3>強力なマウス</h3>
<p>キーボードによるインタラクションについて説明してきましたが、マウスではどうでしょうか。次の関数に気付いている人も多いかもしれませんね。</p>
<pre><code class="cpp">void testApp::mouseMoved(int x, int y ){

}

void testApp::mouseDragged(int x, int y, int button){

}

void testApp::mousePressed(int x, int y, int button){

}

void testApp::mouseReleased(int x, int y, int button){

}
</code></pre>

<p>マウスによるインタラクションを試すために、MouseInteractionプロジェクトを新たに作成してください。</p>
<p><img alt="&quot;Mouse Interaction Project&quot;" src="images//MouseInteraction01.png" /></p>
<p>key関数と同じ様にmouse関数にも以下のコードを追加してみましょう。</p>
<pre><code class="cpp">void testApp::mouseMoved(int x, int y){
    cout &lt;&lt; &quot;mouseMoved: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl;
}

void testApp::mouseDragged(int x, int y, int button){
    cout &lt;&lt; &quot;mouseDragged: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot; button: &quot; &lt;&lt; button &lt;&lt; endl;
}

void testApp::mousePressed(int x, int y, int button){
    cout &lt;&lt; &quot;mousePressed: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot; button: &quot; &lt;&lt; button &lt;&lt; endl;
}

void testApp::mouseReleased(int x, int y, int button){
     cout &lt;&lt; &quot;mouseReleased: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot; button: &quot; &lt;&lt; button &lt;&lt; endl;
}
</code></pre>

<p>cout構文内のxとyは、マウスをクリックした箇所の座標を表しています。
プログラムを実行して下記の様に表示されるか確認してください。</p>
<pre><code class="cpp">mouseMoved: 627, 500
mouseMoved: 619, 500
mouseMoved: 610, 500

...

mouseMoved: 426, 473
mouseMoved: 426, 476
mouseMoved: 427, 478
mousePressed: 426, 478 button: 0
mouseDragged: 427, 477 button: 0

...

mouseDragged: 548, 411 button: 0
mouseDragged: 547, 411 button: 0
mouseDragged: 546, 411 button: 0
mouseReleased: 546, 411 button: 0
mouseMoved: 544, 411
mouseMoved: 543, 411
mousePressed: 543, 411 button: 0
mouseDragged: 542, 411 button: 0

...

mouseDragged: 433, 396 button: 0
mouseDragged: 433, 377 button: 0
mouseReleased: 433, 377 button: 0
mouseMoved: 434, 370
mouseMoved: 433, 367
</code></pre>

<p>いくつか重要な事があります。まず“mouseMoved”メッセージが沢山表示されているかと思います。実際に、この関数は1ピクセル単位でマウスが動くたびに呼び出されますので、コードを追加する時には注意しましょう。次に、"mouseDragged"の前に必ず"mousePressed"がある事に気付くと思います。そして、“mouseMoved”へ戻る前に、沢山の"mouseDragged"が表示され、“mouseReleased”が表示されています。</p>
<h3>インタラクション・グラフィックス</h3>
<p>Interacting With Graphics
~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>So now we know how to make something happen when the user does any mouse business. But printing to the console is hardly the kind of interaction we want. When it comes to interacting with GUI applications, the mouse is used in a variety of ways: simple clicking, double-clicking, dragging, hovering, gestures, etc. One very basic interaction is "user clicks on something, something happens." Let's see how we might accomplish this.</p>
<p>Suppose, for instance, that we wanted our trusty circle to expand whenever the user clicks on it. Let's start by setting up a new project called MouseInteraction2. It will start out very similar to our 'MouseInteraction' project:</p>
<pre><code class="cpp">int myCircleX=200;
int myCircleY=300;
int myCircleRadius=100;

void testApp::setup(){
}

void testApp::update(){
}

void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, myCircleRadius);
}
</code></pre>

<p>As you can see, we have added a new variable called 'myCircleRadius'. It should be clear that, if we want the circle to grow, all we have to do is increase myCircleRadius. The trick will be to determine when this should happen.</p>
<p>It's clear that it has something to do with the mousePressed function that we just discovered above. We know that mousePressed is called every time the user clicks the mouse, so if we simply drop 'myCircleRadius++;' into the mousePressed function, we would be half way there. Try this out.</p>
<pre><code class="cpp">void testApp::mousePressed(int x, int y, int button){
    myCircleRadius++;
}
</code></pre>

<p>You should find that the circle grows every time you click the mouse, regardless of whether or not your clicked inside the circle. But our challenge is to only grow the circle when the use clicks <em>inside</em> of it. So how might we go about this?</p>
<p>Well, luckily we are dealing with a circle, which will make it significantly easier. Because if we can determine the distance between the center of the circle and the location of the mouse click, we can compare this distance to the radius, and if it is less than the radius, then the click was inside the circle. Take a look at the diagrams:</p>
<p>image:images/hit-test-01.png["Hit Test 1"]</p>
<p>We know that the radius of the circle = 300, and we know that the mouse click is 230 pixels away from the center of the circle. So, was the mouse click inside the circle?</p>
<p>image:images/hit-test-02.png["Hit Test 2"]</p>
<p>In this case, we know that the mouse click was 90 pixels from the center of the circle, so the click was clearly inside the circle.</p>
<p>So how do we measure this distance? openFrameworks provides a function called 
ofDist([x1], [y1], [x2], [y2]) that will save us from doing any basic trigonometry. All we have to do is give it our two coordinates. </p>
<pre><code class="cpp">void testApp::mousePressed(int x, int y, int button){
    float distance = ofDist(myCircleX, myCircleY, x, y);
    cout &lt;&lt; distance &lt;&lt; endl;

    myCircleRadius++;
}
</code></pre>

<p>The 'cout' will allow us to check what kind of values we are getting from ofDist. Run your program now. Click around the screen and see what kind of values get printed in your console.</p>
<p>So the only thing left to do is compare 'myCircleRadius' to 'distance', and we can do this using a simple if statement.</p>
<pre><code class="cpp">void testApp::mousePressed(int x, int y, int button){
    float distance = ofDist(myCircleX, myCircleY, x, y);
    if(distance &lt; myCircleRadius)
    {
        myCircleRadius++;
    }  
}
</code></pre>

<p>This code says "first calculate the distance btween the center of the circle and the mouse click. Then compare 'distance' to 'myCircleRadius'. If (and only if) distance is LESS THAN myCircleRadius, increment myCircleRadius by 1."</p>
<p>Et voila!  You are interacting with graphics!</p>
<h2>Technical Topics</h2>
<p>In the example above, we looked at one of the most basic control structures: the http://www.cprogramming.com/tutorial/lesson2.html[if statement]. Control structures like the if statement allow you to alter the flow of your program based on criteria that you define. Control structures are not an openFrameworks "thing", but rather a feature of the <code>c++</code> language. Let's take a moment to review a few basics of the <code>c++</code> language.</p>
<p>Variables</p>
<pre><code>
In the &quot;Adding Movement&quot; section, we introduced the idea of using variables to represent values that change over the course of your program. We used 2 integers, or *int*s - 'int myCircleX' and 'int myCircleY' - to represent the location of a circle. When you declare a variable as an 'int', you are telling the computer &quot;I only intend to put whole numbers into this variable.&quot;  This made sense in our example because we were moving a circle by a single pixel, so we didn't need to worry about fractions. 

But there will be times when you do need to have a variable that can hold a fraction, or something completely different, such as letters, words, even a location in memory. There are variable types for each of these situations. Here is a short list of some of them from http://www.cplusplus.com/doc/tutorial/variables/[cplusplus.com]

image:images/variable-types.png[&quot;Variable Types&quot;]

So, as you can see, our basic integer takes up 4 bytes in memory. This is a finite amount of memory, and therefore there is limited (but pretty huge!) range of values that it can hold: namely, -2,147,483,648 to 2,147,483,647. If you need to store higher (or lower) numbers, you'd have to use a 'long int', which (contrary to the diagram) can go up to 9,223,372,036,854,775,807 and down to -9,223,372,036,854,775,808. 

It may be unintuitive to make such distinctions when dealing with variables. A number is a number, right? Why differentiate between a decimal number and a whole number? The reason has to do with how values are stored in your computer's memory. Ultimately, by giving the programmer the responsibility of declaring what range and precision their variables need, the program can run that much more efficiently.

[TIP]
=====================================================================
Compile and run this program to see information about how your computer treats different kinds of variables.

~~~~{.cpp}
#include &lt;iostream&gt;
#include &lt;limits.h&gt;
#include &lt;float.h&gt;
using namespace std;

int main ()
{
    cout &lt;&lt; &quot;type \t\tsize \tmin \t\t\tmax&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;---------------------------------------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;bool\t\t&quot; &lt;&lt; sizeof(bool) &lt;&lt; endl;
    cout &lt;&lt; &quot;char\t\t&quot; &lt;&lt; sizeof(char) &lt;&lt; &quot;\t&quot; &lt;&lt; CHAR_MIN &lt;&lt; &quot;\t\t\t&quot; &lt;&lt; CHAR_MAX &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned char\t&quot; &lt;&lt; sizeof(unsigned char) &lt;&lt; &quot;\t\t\t\t&quot; &lt;&lt; UCHAR_MAX &lt;&lt; endl;
    cout &lt;&lt; &quot;short\t\t&quot; &lt;&lt; sizeof(short) &lt;&lt; &quot;\t&quot; &lt;&lt; INT_MIN &lt;&lt; &quot;\t\t&quot; &lt;&lt; INT_MAX &lt;&lt; endl;
    cout &lt;&lt; &quot;int\t\t&quot; &lt;&lt; sizeof(int) &lt;&lt; &quot;\t&quot; &lt;&lt; INT_MIN &lt;&lt; &quot;\t\t&quot; &lt;&lt; INT_MAX &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned int\t&quot; &lt;&lt; sizeof(unsigned int) &lt;&lt; &quot;\t\t\t\t&quot; &lt;&lt; UINT_MAX &lt;&lt; endl;
    cout &lt;&lt; &quot;float\t\t&quot; &lt;&lt; sizeof(float) &lt;&lt; &quot;\t&quot; &lt;&lt; FLT_MIN &lt;&lt; &quot;\t\t&quot; &lt;&lt; FLT_MAX &lt;&lt; endl;
    cout &lt;&lt; &quot;long\t\t&quot; &lt;&lt; sizeof(long) &lt;&lt; &quot;\t&quot; &lt;&lt; LONG_MIN &lt;&lt; &quot;\t&quot; &lt;&lt; LONG_MAX &lt;&lt; endl;
    cout &lt;&lt; &quot;double\t\t&quot; &lt;&lt; sizeof(double) &lt;&lt; &quot;\t&quot; &lt;&lt; DBL_MIN &lt;&lt; &quot;\t\t&quot; &lt;&lt; DBL_MAX &lt;&lt; endl;
    return 0;
}
~~~~
=====================================================================

There is one important kind of variable that is not covered in this chart: 'string'. A string can hold a sequence of characters. ... more to come ...

Loops
~~~~~

Loops are perhaps one of the most important things to be comfortable with as a programmer. They are, arguably, the main advantage of using a computer: doing something over and over again very rapidly is the definition of what a computer is good at. There are a few different kinds of loops, and it is important to be familiar with all of them.

Suppose you want to a circle every 20 pixels across your window. One option would be to copy and paste ofCircle commands like this:

~~~~{.cpp}
void testApp::draw(){
    ofCircle(20, 300, 10);
    ofCircle(40, 300, 10);
    ofCircle(60, 300, 10);
    ofCircle(80, 300, 10);
    ofCircle(100, 300, 10);
    ofCircle(120, 300, 10);
    // repeat 
    ofCircle(1020, 300, 10);
}
~~~~

That would be over 50 lines of code - ugh. And what if you decided you wanted them every 30 pixels instead of every 20 pixels?  You'd have to go back and edit each line of code. And what if the size of your window changed?  This is clearly unacceptable. Consider this code:

~~~~{.cpp}
void testApp::draw(){
    int x = 10;

    ofCircle(x, 300, 10);
    x += 20;
    ofCircle(x, 300, 10);
    x += 20;
    ofCircle(x, 300, 10);
    x += 20;
    ofCircle(x, 300, 10);
    x += 20;
    // copy and paste 47 more times
}
~~~~

In some ways, this is even worse. We've turned one line of code per circle into 2 lines of code per circle. However, there is one very important difference: in this case, the 2 lines are identical every time. We have &quot;abstracted&quot; the task -- that is, we have taken out the specifics and made it into a more general form. 

So now, all that's left to do is to tell the computer to do those 2 lines of code a bunch of times instead of us pasting it in ourselves. This is where loops come in.

do...while loop
^^^^^^^^^^^^^^^

All loops basically take the same form:

. Set up some initial values (initialization)
. Execute the body of the loop 
. Decide whether to go back to step 2 or exit the loop

The simplest loop is the do/while loop. As the name suggests, this loop allows you to ask the computer to &quot;do&quot; something &quot;while&quot; a condition is met. Using a do/while loop, we can easily draw 51 circles

~~~~{.cpp}
void testApp::draw(){
    int i = 0;
    int x = 20;
    do {
        ofCircle(x, 300, 10);
        x+=20;
        i++;
    } while( i &lt; 51 );
}
~~~~

So what just happened?  Let's go through the code step by step as if we were the computer. I apologize that this is the most tedious thing you will ever read, but hopefully it will illustrate what is going on in the loop.

. Initialize a variable called i and set it equal to 0
. Initialize a variable called x and set it equal to 20
. Draw a circle at (20, 30) with a radius of 10
. Increment x by 20 (it now equals 40)
. Increment i by 1 (it now equals 1)
. Is 1 less than 51?  
.. Yes!  Go back to the beginning of the loop
. Draw a circle at (40, 30) with a radius of 10
. Increment x by 20 (it now equals 60)
. Increment i by 1 (it now equals 2)
. Is 2 less than 51?  
.. Yes!  Go back to the beginning of the loop
. Draw a circle at (60, 30) with a radius of 10
. Increment x by 20 (it now equals 80)
. Increment i by 1 (it now equals 3)
. Is 3 less than 51? 
.. Yes!  Go back to the beginning of the loop
. [REPEAT 46 TIMES UNTIL i=50 and x=1000]
. Draw a circle at (1000, 30) with a radius of 10
. Increment x by 20 (it now equals 1020)
. Increment i by 1 (it now equals 51)
. Is 51 less than 51? 
.. NO!  Exit out of loop and continue on to whatever comes next

[TIP]
=====================================================================
We could actually make this even a bit more efficient and make the 'x' variable to double duty like this:
~~~~{.cpp}
int x = 20;
do {
    ofCircle(x, 300, 10);
    x+=20;
} while(x &lt; ofGetWidth());
~~~~
This has the added advantage of being immune to changes in window size. Try making the window bigger and smaller -- the circles will always be drawn to the end of the window.
=====================================================================

while loop
^^^^^^^^^^

In a while loop, the 'while' part is simply moved up to the top of the loop. So if we want to draw a string of circles with a while loop, it would look like this:

~~~~{.cpp}
int i = 0;
int x = 20;
while(i &lt; 51)
{
    ofCircle(x, 300, 10);
    x+=20;
    i++;
}
~~~~

The only difference between a do...while loop and a while loop is that the the condition happens first, before the loop body runs. For example, suppose we edited our do...while loop like this:

~~~~{.cpp}
int x = 10;
do {
    ofCircle(x, 300, 10);
    x += 20;
} while( x &lt; mouseX );
~~~~

Notice how we've changed the condition so that the circles will be drawn until 'x' is less than the x position of the mouse. Run this code and see what happens. Notice, in particular, that there is always 1 circle on the screen regardless of how far to the left the mouse goes. Now transform that into a while loop:

~~~~{.cpp}
int x = 10;
while( x &lt; mouseX )
{
    ofCircle(x, 300, 10);
    x += 20;
}
~~~~

Now, if you move your mouse beyond the left side of the window, nothing at all is drawn. This is because before the body of the loop is executed (namely the ofCircle draw command), the test is done. So if mouseX is less than x, no circles are drawn at all.

for loop
^^^^^^^^

We've saved the best for last. The for loop is probably the one that you will use the most. This might be because it combines all 3 parts of a loop (initialization, condition, and incrementing) into one compact syntax. Let's draw the same circles using a for loop:

~~~~{.cpp}
int x = 20;
for(int i=0; i&lt;51; i++)
{
    ofCircle(x, 300, 10);
    x+=20;
}
~~~~

The syntax of the for loop can be a little daunting at first, but let's take it apart piece by piece. The first part is initialization: &quot;int i=0;&quot;  Pretty straightforward: we now have an integer called i that we have set to 0. The next part is the condition: &quot;i&lt;51&quot;. In other words, we want the loop to continue so long as i is less than 51. And lastly,  the increment: &quot;i++&quot;. After every iteration of the loop, we will increment i by 1.

We saw each of these things in the other kind of loops. THe only difference here is that they are all smushed into one line. 

Arrays
~~~~~~

Another strength of computers is that they are encyclopedic: that is, they can keep track of a huge number of things at a time. Suppose we want to draw six thousand moving particles?  We know from the loop section that it is trivial to do something over and over again, but so far, we have only used loops to achieve a relatively consistent pattern. If we want do draw tons of particles, each with their own position, things get a little more complicated.

.50000 particles!
image::images/Arrays01.png[&quot;Arrays!&quot;,width=500]

~~~~{.cpp}
float circle1x;
float circle1y;
float circle1r;
float circle2x;
float circle2y;
float circle2r;
float circle3x;
float circle3y;
float circle3r;

void testApp::setup(){
    ofSetFrameRate(24);

    circle1x = ofRandom(0, ofGetWidth());
    circle1y = ofRandom(0, ofGetHeight());
    circle1r = ofRandom(10, 40);

    circle2x = ofRandom(0, ofGetWidth());
    circle2y = ofRandom(0, ofGetHeight());
    circle2r = ofRandom(10, 40);

    circle3x = ofRandom(0, ofGetWidth());
    circle3y = ofRandom(0, ofGetHeight());
    circle3r = ofRandom(10, 40);

}

void testApp::update(){
    circle1x += ofRandom(-1,1);
    circle1y += ofRandom(-1,1);

    circle2x += ofRandom(-1,1);
    circle2y += ofRandom(-1,1);

    circle3x += ofRandom(-1,1);
    circle3y += ofRandom(-1,1);
}

void testApp::draw(){
    ofCircle(circle1x, circle1y, circle1r);

    ofCircle(circle2x, circle2y, circle2r);

    ofCircle(circle3x, circle3y, circle3r);
}
~~~~

TIP: Notice the use of ofRandom(). This function will return a random number. It takes 2 arguments: the minimum possible value and the maximum possible value. What I am saying in this code is &quot;give me a number between 0 and the width of the screen.&quot;

Technically this works, but we have only drawn 3 circles, and already the code is getting unwieldy. We want to draw 1000! We clearly have a bunch of variables that are used in very similar ways. Why not group, say, all of the x coordinates into a single set, and all of the y coordinates, etc.?  

These sets are called arrays. Check out the following code:

~~~~{.cpp}
float circleX[3];
float circleY[3];
float circleRad[3];

void testApp::setup(){
    ofSetFrameRate(24);

    circleX[0] = ofRandom(0, ofGetWidth());
    circleY[0] = ofRandom(0, ofGetHeight());
    circleRad[0] = ofRandom(10, 40); 

    circleX[1] = ofRandom(0, ofGetWidth());
    circleY[1] = ofRandom(0, ofGetHeight());
    circleRad[1] = ofRandom(10, 40); 

    circleX[2] = ofRandom(0, ofGetWidth());
    circleY[2] = ofRandom(0, ofGetHeight());
    circleRad[2] = ofRandom(10, 40); 
}

void testApp::update(){

    circleX[0] += ofRandom(-1,1);
    circleY[0] += ofRandom(-1,1);

    circleX[1] += ofRandom(-1,1);
    circleY[1] += ofRandom(-1,1);

    circleX[2] += ofRandom(-1,1);
    circleY[2] += ofRandom(-1,1);
}

void testApp::draw(){

    ofCircle(circleX[0], circleY[0], circleRad[0]);
    ofCircle(circleX[1], circleY[1], circleRad[1]);
    ofCircle(circleX[2], circleY[2], circleRad[2]);
}
~~~~

As you can see, we've replaced int circle1x, int circle2x, and int circle3x with simply int circleX[3]. Now circleX is an &quot;array&quot; that can hold up to 3 integers, rather than just 1. Read a little further, and you will see that, in order to assign a value to one of the ints in the array, you use the square brackets, like this: circleX[0] = 50;  

Down in the draw function, you can see that we use the same syntax to use the values that we have previously assigned to a particular slot in the array.

But this is still kind of a mess. One sign that you might not be utilizing loops as much as possible is if you see patterns in your code -- that is, similar sequences of code over and over again. So let's try to clean this up even more using some 'for' loops. 

~~~~{.cpp}
float circleX[3];
float circleY[3];
float circleRad[3];

void testApp::setup(){
    ofSetFrameRate(24);

    for(int i=0; i&lt;3; i++)
    {
        circleX[i] = ofRandom(0, ofGetWidth());
        circleY[i] = ofRandom(0, ofGetHeight());
        circleRad[i] = ofRandom(10, 40); 
    }
}

void testApp::update(){

    for(int i=0; i&lt;3; i++)
    {
        circleX[i] += ofRandom(-1,1);
        circleY[i] += ofRandom(-1,1);
    }
}

void testApp::draw(){

    for(int i=0; i&lt;3; i++)
    {
        ofCircle(circleX[i], circleY[i], circleRad[i]);
    }
}
~~~~

Now, instead of putting hard-coded numbers between the square brackets, we use the 'i' variable of our for loop.

#define
^^^^^^^

A wise person once said: the primary virtue of a programer is laziness. Suppose you wanted to change the number of circles that appear on the screen from 3 to 500. Obviously, the first step would be to change circleX[3] to circleX[500], and likewise circleY and circleRad. Oh, but that's not all. You'd still have to go through every &quot;for&quot; loop and change i&lt;3 to i&lt;50. That's a lot of work!  

It would be great if we could use a variable to keep track of how many items we have in our array! It might look something like this:

~~~~{.cpp}
int num = 500;
float circleX[num];
float circleY[num];
float circleRad[num];
~~~~

Unfortunately, this isn't possible. You can't use a variable to declare a variable. 

Instead, we will use a new thing called a #define (pronounced: &quot;pound define&quot;). Take a look at this:

~~~~{.cpp}
#define NUM_CIRCLES 500

float circleX[NUM_CIRCLES];
float circleY[NUM_CIRCLES];
float circleRad[NUM_CIRCLES];
int circleR[NUM_CIRCLES];
int circleG[NUM_CIRCLES];
int circleB[NUM_CIRCLES];

void testApp::setup(){
    ofSetFrameRate(24);

    for(int i=0; i&lt;NUM_CIRCLES; i++)
    {
        circleX[i] = ofRandom(0, ofGetWidth());
        circleY[i] = ofRandom(0, ofGetHeight());
        circleRad[i] = ofRandom(10, 40); 

        circleR[i] = ofRandom(0, 255);
        circleG[i] = ofRandom(0, 255);
        circleB[i] = ofRandom(0, 255);
    }
}

void testApp::update(){

    for(int i=0; i&lt;NUM_CIRCLES; i++)
    {
        circleX[i] += ofRandom(-1,1);
        circleY[i] += ofRandom(-1,1);
    }
}

void testApp::draw(){

    for(int i=0; i&lt;NUM_CIRCLES; i++)
    {
        ofSetColor(circleR[i], circleG[i], circleB[i]);
        ofCircle(circleX[i], circleY[i], circleRad[i]);
    }
}
~~~~

At the very top, notice the line &quot;#define NUM_CIRCLES 500&quot;. This isn't technically a line of `c++` code, but rather a message to your compiler. It tells the compiler &quot;before you start compiling code, anywhere you see NUM_CIRCLES, replace it with 500&quot;. That's it! A #define is one of a couple messages that you can send to the compiler (or, more accurately, the preprocessor), known more broadly as http://www.cplusplus.com/doc/tutorial/preprocessor/[preprocessor directives]. We will talk more about them at a later date., but for now, all you need to know is that #define is a very simple find/replace procedure. 

Functions
</code></pre>

<pre><code class="cpp">void drawStar(float xpos, float ypos, float radius, int npts)
{
    bool useInner=false;
    ofBeginShape();
    for(int i=0; i&lt;360; i+=360/npts)
    {
        int r = useInner ? radius*.6 : radius;
        int x = xpos + cos( ofDegToRad(i) ) * r;
        int y = ypos + sin( ofDegToRad(i) ) * r;
        ofVertex(x, y);
        useInner = !useInner;
    }
    ofEndShape();
}
</code></pre>

        		</div>
            </div><!-- End Page Wide -->
        
    	

    	</div>
              
      </div><!-- End Body Wrap -->
      
      <div id="footer">
        
  <p id="credits">

Last updated 
  
Sunday, 06 May 2012 09:38:37 UTC
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/openframeworks/ofSite/commit/

9aebfefa1584e6dbd1767de3a236b477ed0e47cb
">

9aebfefa1584e6dbd1767de3a236b477ed0e47cb
</a>

<!--br/>RSS feeds for <a href="/blog/feed">Entries</a-->

<br/>

</p>




<!--tracking -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12810824-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>






      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>




