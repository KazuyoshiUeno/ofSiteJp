








<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>openFrameworks.jp</title>

<!-- syntax highlighting for the documentation -->
<script src="http://localhost:8080/js/shCore.js" type="text/javascript"></script>
<script src="http://localhost:8080/js/shAutoloader.js" type="text/javascript"></script>
<script src="http://localhost:8080/js/shBrushCpp.js" type="text/javascript"></script>
<script src="http://localhost:8080/js/shBrushJava.js" type="text/javascript"></script>
<link href="http://localhost:8080/css/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://localhost:8080/css/shThemeDefault.css" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" href="http://localhost:8080/css/style.css" media="all" />
<link rel="stylesheet" type="text/css" href="http://localhost:8080/css/print.css" media="print" />
<link href='http://fonts.googleapis.com/css?family=Questrial' rel='stylesheet' type='text/css'>
<link rel="search" type="application/opensearchdescription+xml" href="http://localhost:8080/opensearch.xml" title="openFrameworks" />

<link rel="shortcut icon" href="http://localhost:8080/favicon.ico" />
<link rel="icon" href="http://localhost:8080/favicon.ico" type="image/x-icon" />

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript" src="http://localhost:8080/js/jquery.timeago.js" type="text/javascript"></script>

<meta name="google-site-verification" content="RiGtl9pFuFnUeEQ4MU1miiutTR5mmCPUi38YLCn-M-g" />


    <script src="http://localhost:8080/js/jquery.columnizer.min.js"></script>
    <script src="http://localhost:8080/js/documentation.js"></script>
  </head>
  <body>
    <div id="content">
      
  

<div id="head">

		<div id="head-left">
			<a href="http://localhost:8080" class="nohover"><img src="http://localhost:8080/images/ofw-logo.png" border="0" alt="openFrameworks" /></a>
		</div>

		<div id="head-right">
		<ul>
		
	        <li><a href="http://localhost:8080/about" class="">about</a></li>
	        <li><a href="http://localhost:8080/download" class="" >download</a></li>
	        <li><a href="http://localhost:8080/documentation" class="active">documentation</a></li>
	        <li><a href="http://localhost:8080/gallery" class="">gallery</a></li>
	        <li><a href="http://localhost:8080/community" class="">community</a></li> 
		</ul>
		
		<ul class="menu-externals">
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://forum.openframeworks.cc/index.php" target="_blank">forum</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://ofxaddons.com" target="_blank">addons</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://wiki.openframeworks.cc/" target="_blank">wiki</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://github.com/openframeworks/openFrameworks" target="_blank">github</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://openframeworks.cc/list-info" target="_blank">mailing list</a></li>
		</ul>
			<!--form method="get" id="searchform" action="/index.php">
			<input type="text" value="" name="s" id="s" class="search_input" /> <input type="submit" value="Search" class="search_button"/>
			</form-->
			<!--form method="post" action="http://scripts.dreamhost.com/add_list.cgi">
                <input type="hidden" name="list" value="list@openframeworks.cc" />
                <input type="hidden" name="domain" value="openframeworks.cc" />
                <input type="hidden" name="url" value="http://openframeworks.cc/list-info/subscribe.html"  />
                <input type="hidden" name="unsuburl" value="http://openframeworks.cc/list-info/unsubscribe.html" />
                <input type="hidden" name="alreadyonurl" value="http://openframeworks.cc/list-info/already.html" />
                <input type="hidden" name="notonurl" value="http://openframeworks.cc/list-info/not.html" />
                <input type="hidden" name="invalidurl" value="http://openframeworks.cc/list-info/invalid.html" />
                <input type="hidden" name="emailconfirmurl" value="http://openframeworks.cc/list-info/confirm.html" />
                <input type="hidden" name="emailit" value="1" />
                name: <input name="name" /> <br />
                email: <input name="email" /><br />
                <span class='but'><input type="submit" name="submit" value="subscribe" /></span> <br/ >
                <span class='but'><input type="submit" name="unsub" value="unsubscribe" /></span>
            </form-->
		</div>
</div><!-- head -->



      <div id="body-wrap">	
	    <div class="page-wide">
            <ul class="submenu">
                <li><a href="/documentation">reference</a></li>
                <li><a href="/tutorials">tutorials</a></li>
            </ul>

            
            <h1>tutorials</h1>    


        	<div class="submenucol-left">
        	    <ul class="categories">
                        <li><a href="/tutorials/introduction">introduction</a></li>
                </ul>
            </div><!-- End Page Wide -->

        	<div class="submenucol-right">
        	    <h2>ProcessingユーザーのためのopenFrameworks</h2>
        	    <span class="article_meta">2008/06/30 14:16:00&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;<a href="http://www.stfj.net">Zach Gage</a></span><br/>
        	    <div class="article">
        	    
  <h2>Contents</h2>
<ul>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#An_overview_of_OpenFrameworks_for_processing_junkies.">1 Processingジャンキーのための、openFrameworksの概観</a></p>
<ul>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#How_Processing_Actually_Works">1.1 Processingは実際どのように動作しているのか?</a></p>
<ul>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#What_is_class_extending.3F_.28base_and_sub_classes.29.3F">1.1.1 クラスの拡張とは? (基底クラスとサブクラスって何?)</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Ok.2C_so_what_does_this_have_to_do_with_Processing.3F">1.1.2 了解、じゃあProcessingではそれはどうやるの?</a></li>
</ul>
</li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#How_OpenFrameworks_Works.">1.2 openFramewroksはどうやって動いているの?</a></p>
<ul>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Main.cpp_In-depth">1.2.1 Main.cppの詳細</a></li>
</ul>
</li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Java_vs._C.2B.2B_Compile_Processes">1.3 Java vs. C++ コンパイルのプロセス</a></p>
</li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#How_Classes_Work_in_C.2B.2B_.28Two_Files.21.3F.29">1.4 C++ではクラスはどうやって動かすの? (2つのファイル!?)</a></p>
<ul>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#testApp.h">1.4.1 testApp.h</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#testApp.cpp">1.4.2 testApp.cpp</a></li>
</ul>
</li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#What_the_Fu.2A.26.3F_.28a_very_basic_introduction_to_pointers.29.">1.5 なんだ*&amp;れは? (ポインタの初歩).</a></p>
<ul>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Value_vs._Reference">1.5.1 値と参照Value vs. Reference</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#.26_and_.2A">1.5.2 &amp;と*</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#So_Where_Do_I_use_This.3F">1.5.3 どんな状況で使うのか?</a></li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Basic_Data-types">1.5.4 基本のデータ型</a></p>
<ul>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#The_Processing_String_Exception">1.5.4.1 Processingの文字列の例外</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#PImage.2C_updatePixels.28.29_vs._ofTexture.2C_pixels.5B.5D">1.6 PImage, updatePixels() 対 ofTexture, pixels[]</a></p>
<ul>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#How_are_pixel_values_stored_without_a_Color_object.3F">1.6.1 何故Pixelの値はColorオブジェクトとして格納されていないの?</a></li>
</ul>
</li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Common_Problems_With_C.2B.2B_.2F_Misc._Topics">1.7 C++に関する既知の問題 / その他のトピックス</a></p>
<ul>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Expecting_implicit_data_conversion.3F">1.7.1 暗黙のデータ変換の期待</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Changing_window_size">1.7.2 ウィンドウのサイズ変更</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Update.28.29_and_Draw.28.29.3F">1.7.3 Update()とDraw()?</a></li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#How_in_the_world_do_I_print_to_the_console.3F">1.7.4 コンソールに出力するには?</a></p>
<ul>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#printf">1.7.4.1 printf</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#iostream">1.7.4.2 iostream</a></li>
</ul>
</li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Smoothing_not_working_on_filled_shapes.3F">1.7.5 塗り潰しの図形は、スムージングできない?</a></p>
</li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Displaying_video_problem.2Ffeature_related_to_ofSetColor">1.7.6 ofSetColorに関するビデオ表示の問題</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Processing_background.28.29_vs._OF_ofBackground.28.29">1.7.7 Processingのbackground() 対 oFのofBackground()</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#ofFill.28.29_.2F_ofNoFill.28.29_vs._processing_fill.28.29_noFill.28.29">1.7.8 ofFill() / ofNoFill() 対 Processingのfill() noFill()</a></li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Math_functions.2C_and_where_they_come_from_.28no_more_Math..2A.29">1.7.9 数学関数とそれはどこから来たのか?(ノー・モア Math.*)</a></p>
<ul>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#cmath">1.7.9.1 cmath</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#ofConstants">1.7.9.2 ofConstants</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#ofMath">1.7.9.3 ofMath</a></li>
</ul>
</li>
<li>
<p><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Structs.2C_what_are_they_for.2C_and_how_can_we_use_them.3F">1.7.10 構造体、何のために、どうやって使うのか?</a></p>
</li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Memory_Management_and_You">1.7.11 メモリ管理</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#Basic_Logic_Problems">1.7.12 基本的な論理構造の問題</a></li>
<li><a href="file:///home/arturo/Downloads/ittyeditor-read-only/ittyeditor-example.html#accidental_breakpoints_in_Xcode_and_Why_Having_a_Debugger_Rocks">1.7.13 Xcodeのブレイクポイントと、何故デバッガが凄いのか</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Processingは実際どのように動作しているのか?</h2>
<p>もし、あなたがある程度Processingでプログラミングしてきたのなら、あなたは当然クラスを使ったことがあると受けとめて良いでしょう。Javaのクラスの特徴一つは、もしかしたら馴染みがないかもしれませんが、多態性(ポリモーフィズム、クラスの継承)です。</p>
<h3>クラスの拡張とは? (基底クラスとサブクラスって何?)</h3>
<p>クラスの拡張は、基本となる一つのクラスから、機能を追加したクラスを新規に生成するための方法です。</p>
<p>もし、例えばあなたがビデオゲームのようなものを作っていたとします。あなたは「敵」というクラスを作り、その外観を画像として読みこんだり、その動きを定義したり、スクリーンの望みの場所に描画したりするでしょう。そのコードは以下のようになるでしょう。</p>
<pre><code class="cpp">    class Enemy
    {
        int x; //x position
        int y; //y position
        public void init(String pathToEnemyPicture, int startX, int startY)
        {
            //load in the enemy picture from the hard-drive
            //assign starting positions
        }

        public void move()
        {
            //move, maybe shoot at player
        }
        public void draw()
        {
            //draw my picture to the screen at the proper location
        }
    }
</code></pre>

<p>しかし、もし複数の種類の敵を作りたかったり、それぞれ違う描画のされかたをしたい場合はどうやるのでしょう? こうしたとき、クラスの継承が役立ちます。全ての敵は、以前としてInit()で自身を初期化してmove()でスクリーンを動くようにしていきましょう。わたしたちが変更したい唯一の機能は、それぞれの構成をdraw()関数で描画することです。</p>
<p>Enemyクラスは「基底クラス」と呼ばれる方法で使用しましょう。基底クラス自体は初期化されることはおそらくありません。その代わり
We are now using the Enemy class as what is called a Base Class. A Base Class is a class that probably won't ever be instantiated, only inherited by other classes. Because the draw function is the only one we want to change, we don't need to write either the init() or move() functions. By declaring the draw() function again however, we are doing something called function re-definition. This is where you re-declare a function that has already been declared, in effect overwriting it for this subclass of Enemy.</p>
<p>For example, in Java,</p>
<pre><code class="cpp">    class DoubleEnemy extends Enemy
    {
        public void draw()
        {
            //draw myself twice
        }
    }
</code></pre>

<p>which in C++ would be something like,</p>
<pre><code class="cpp">    //on a &quot;DoubleEnemy.h&quot; file
    class DoubleEnemy: public Enemy // class[className]:[privacy][extended Class]{}
    {
        public void draw();//the actual code for draw would be on the &quot;DoubleEnemy.cpp&quot; file
    }; // note the &quot;;&quot; at the end of the class statement
</code></pre>

<p>Because DoubleEnemy extends our abstract Enemy class, it inherits all of the functions and variables that we declared in the Enemy class. Because of this, we will never have to write a new init or move function. We could even create another specialized Enemy class:</p>
<pre><code class="cpp">    //on a &quot;TripleEnemy.h&quot; file
    class TripleEnemy : public Enemy
    {
        public void draw(); //draw myself three times
    };
</code></pre>

<p>Now we have two enemy types that know how to move and initialize themselves but each display differently. Another advantage to this is that if we ever have to change how enemies move or initialize, we only need to change it once, in the base class, and the change will take effect through all of our specialized enemy types.</p>
<h3>了解、じゃあProcessingではそれはどうやるの?</h3>
<p>Although Processing hides it from you through their compiler, Processing is actually an engine running a Base Class (pApplet). Anything that you write, including classes, inside the Processing application automatically extends this base class that the Processing engine then runs. When you write draw() and setup() functions, you are actually re-defining the draw() and setup() functions that are in the processing base class.</p>
<h2>openFramewroksはどうやって動いているの?</h2>
<p>OpenFrameworks is built in much the same way as Processing. It just doesn't hide any of the complicated parts from you. However, if you open up testApp.h, right under the #include "ofMain.h" line, you will see a line that says: "class TestApp : public ofSimpleApp{". </p>
<p>This means, the testApp class extends the ofSimpleApp class, just like in processing. Right under that, under "Public:" are all of the functions that testApp is inheriting from ofSimpleApp that it needs to re-write, like in processing.</p>
<p>Every C++ application needs a function called int main() to define where the program starts. Java requires this as well, but Processing hides this fact from you since anything you write is only extending a larger class with that main being called elsewhere. </p>
<p>C++ however must start with int main(). This is called the "entry point" and is the jumping off point for your program. </p>
<p>main.cpp contains this main() function, and essentially contains the code to set your screen size, and kick off an infinite loop which runs your program. If you want to learn more about this, you can read section 2.1, but it's not necessary, and can be confusing at this point.</p>
<h3>Main.cppの詳細</h3>
<p>If you look at any of the OF example files you will see that in the main.cpp file contains two #include statements up at the top. These operate the same way as they do in Processing. </p>
<p>The first one, </p>
<pre><code class="cpp">    #include &quot;ofMain.h&quot;
</code></pre>

<p>adds the entire OpenFrameworks library to the main.cpp class. This allows the class to run two important OF functions, ofSetupOpenGL(), which creates the window to display your application, and ofRunApp(), which runs your application.</p>
<p>If you notice, ofRunApp() is passing a parameter, </p>
<pre><code class="cpp">    new testApp()
</code></pre>

<p>ofRunApp() is passing an instance of the testApp class, which happens to be the second thing included up at the top of main.cpp. ( #include "testApp.h" ) </p>
<p>ofRunApp requires the passed parameter to be a type of ofSimpleApp, which is why when we looked at testApp.h earlier, we noticed it extended ofSimpleApp.</p>
<p>To recap, 
we have main.cpp which includes ofMain and testApp.</p>
<ul>
<li>It includes ofMain to set the screenSize and to call ofRunApp</li>
</ul>
<p>(It includes testApp to have a class to pass ofRunApp.</p>
<p>We also have testApp which includes ofMain</p>
<ul>
<li>It includes ofMain so that any code you write in testApp can benefit from the OpenFrameworks Library.</li>
</ul>
<p>Until you start writing your own classes, it might help to think of testApp.cpp and testApp.h as the main window in Processing. Meaning, any code you write will go into one of those two files, and until you feel comfortable, you won't have to look at anything else in Xcode.</p>
<h2>Java vs. C++ コンパイルのプロセス</h2>
<p>Java and C++ have vastly different compiling processes. It is important to understand the C++ compilation process as each stage of it can produce different types of errors. Knowing what stage produces what type of errors can go a long way towards debugging your project.</p>
<p>In Java, every time you compile, your entire program is run through and changed into byte code. Then when you run your program, a Java interpreter does runtime compilation to make your program work.</p>
<p>C++ is a bit more complicated.</p>
<ul>
<li>
<p>First, the compiler pre-processes your program. This means that it goes through all of your #include statements and copy and pastes chunks of your code to create essentially one gigantic file. (Any statements preceded by a # symbol are targeted at the pre-processor).</p>
</li>
<li>
<p>Second, the compiler parses through your code, making sure that all of your code makes sense, and breaking your code down into parse-trees, which it then translates into Assembly (a very low level language). </p>
</li>
<li>
<p>Thirdly, the Assembly is translated into machine-readable code inside object files.</p>
</li>
<li>
<p>and Lastly, these Object Files are linked together to create your .exe or .app file</p>
</li>
</ul>
<p>One particular advantage that you will notice right away of the C++ compiler style is that when compiling huge programs (like OpenFrameworks applications), sections that have not been updated won't need to be re-compiled. This is easy to understand by opening any example and compiling it. Your first compilation could take 30 seconds to a minute. If you then make changes to testApp.cpp and compile again, compilation should go much quicker. This is because Xcode no longer needs to compile the entire OpenFrameworks library, only your small bit of code that changed.</p>
<h2>C++ではクラスはどうやって動かすの? (2つのファイル!?)</h2>
<p>C++ classes comprise of two files. 
It helps to think of these two classes as a recipe. </p>
<p>The header file (.h) is like the list of ingredients, and contains:</p>
<ul>
<li>Any preprocessor statements there to prevent multiple header definitions</li>
<li>Any include statements to other classes</li>
<li>Any class extension statements</li>
<li>Any variables local to the class</li>
<li>Prototypes of any functions to be contained in the class</li>
<li>And the security settings of these functions and variables (e.g. public, private, protected, etc).</li>
</ul>
<p>and a body file (.cpp) which is like the instructions on what to do with the ingredients and contains:</p>
<ul>
<li>An include statement that references the .h file</li>
<li>All of the code to fill in the function prototypes.</li>
</ul>
<p>To explore this more, open up the testApp.cpp and testApp.h files.</p>
<h3>testApp.h</h3>
<p>All of the code in testApp.h is wrapped in a large if statement called #ifndef. This statement is designed explicitly for the preProcessor stage of compilation. Basically, when the compiler runs through your code before it compiles, it copies and pastes code to make all of the include statements work. If you have included the same header file in multiple places, this can cause a problem for compilation. #ifndef tells the compiler that if whatever variable name you have decided, in this case, _TEST_APP, has already been defined somewhere in the code, not to define it again. It's sort of a hack to make organizing code easier, and is good practice to include in any custom classes you make (with a different variable name obviously).</p>
<p>After this comes the #include statement that brings in all of the OpenFrameworks functionality.</p>
<p>Then comes the class testApp : public ofSimpleApp{ line which is very similar to java's class declaration structure. To compare the two:
C++  :
class [className] : [privacy] [extendedClass]</p>
<p>JAVA/P5:
[privacy] class [className] extends [extendedClass]</p>
<p>Following the class definition is the meat of the .h file, the class itself. The class is broken into privacy blocks. In this case, there is only a public: block, but you may wish to add a private or protected block yourself. In Java, you can define your public and private functions and variables in any order, but in c++ they must be grouped into blocks.</p>
<p>It is important to note that in c++ you must define your classes in your header before you use them (much like your classes local variables). This is called prototyping. At first it can be annoying, but in the end, having all of your functions and variables in an easy to read header file can serve as a sort of documentation for your class, and is especially useful when trying to learn about someone else's classes or the OpenFrameworks library.</p>
<p>It is important to note that classes end with a curly bracket and semi-colon "};" and not just a normal curly bracket. Also important is the #endif which ends the #ifndef statement from the top of the .h file</p>
<p>More information on C++ classes can be found at:
<a href="http://pages.cs.wisc.edu/~hasti/cs368/CppTutorial/NOTES/CLASSES-INTRO.html" title="http://pages.cs.wisc.edu/~hasti/cs368/CppTutorial/NOTES/CLASSES-INTRO.html">http://pages.cs.wisc.edu/~hasti/cs368/CppTutorial/NOTES/CLASSES-INTRO.html</a></p>
<h3>testApp.cpp</h3>
<p>This is where you write the actual code for your class. The syntax for class functions is slightly different than Processing.
C++  :
[ReturnType] [class] :: [functionName] ( [type][variableName]..etc )</p>
<p>JAVA/P5:
[ReturnType] [functionName] ( [type][variableName]..etc )</p>
<h2>なんだ*&amp;れは? (ポインタの初歩).</h2>
<p>Pointers are arguably the most difficult and frustrating part of C++.
I am going to provide a very basic explanation of Pointers here, enough to get some of an idea of what they are about, and how they relate to Java, but if you want a full-blown explanation of how they work and what they can be used for, I suggest reading this excellent and massive tutorial:</p>
<p><a href="http://www.cplusplus.com/doc/tutorial/pointers.html" title="http://www.cplusplus.com/doc/tutorial/pointers.html">http://www.cplusplus.com/doc/tutorial/pointers.html</a></p>
<p>One of the largest differences between C++ and Java is that in Java, except for the basic data-types (byte, short, int, long, float, double, boolean, and char), all values are passed by reference. One important note is that Processing copies Strings by value, whereas C++ copies them by reference like all other classes.</p>
<h3>値と参照Value vs. Reference</h3>
<p>To understand the difference between value and reference you must first understand how the computer stores variables in its RAM.</p>
<p>When you write the Processing line:</p>
<pre><code class="cpp">    int num = 5;
</code></pre>

<p>What the computer does is it goes to the place in its memory that is set up to store integers, picks an empty spot with the right number of bytes to store an integer, places the number 5 in that spot, and then sends the address of that spot to your program which stores it in the "num" variable.</p>
<p>It might be easier to think of the spot in memory that num references as a box containing the number 5:
5
// value stored</p>
<p>2591
// address in memory</p>
<p>and as num as knowing the address this box</p>
<p>num:
2591
// address in memory</p>
<p>Because Processing knows you're using an int and knows to pass it by value, when you ask for what num is with the line print(num), it prints the value of the address that num is referencing.</p>
<p>Try typing this code into processing:</p>
<pre><code class="cpp">    void setup()
    {
    int num = 1;
    addOne(num);
    print(num);
    }

    void addOne(int num)
    {
      num++;
    }
</code></pre>

<p>Unsurprisingly, the program prints "1". We know that this is because when you pass num to a function, the function makes a copy of num and doesn't modify the original. This is called passing by value.</p>
<p>Lets look at another example. Here, instead of passing an integer, we will try passing a class containing an integer. Try typing this code into Processing:</p>
<pre><code class="cpp">    class Test
    {
      int num=0;
    }

    void setup()
    {
    Test test = new Test();
    test.num=1;
    addOne(test);
    print(test.num);
    }

    void addOne(Test test)
    {
      test.num++;
    }
</code></pre>

<p>This time it printed "2". What's going on here? </p>
<p>What happened is that because we created a class Test, Processing recognized that it was not a basic data-type (even though the class contained an int which IS a basic data-type), and passed it to the function by reference. Reference means that instead of passing a copy of the entire Test object to the addOne function, it sent only the address in memory of where the class was stored. </p>
<p>Let's look at boxes again.</p>
<p>test:
52498
// address in memory</p>
<p>52498:
1
// test.num</p>
<p>So when test is passed through addOne(), really just 52498, or whatever the actual memory address of test's data is passed. Because of that, when test's num is incremented, it is actually changed. No copy is ever made.</p>
<p>Java does this because if it were to pass entire objects around constantly everything would slow to a crawl. The basic data-types are small enough to get passed by value, but everything else is passed by reference.</p>
<h3>&amp;と*</h3>
<p>C++ differs from Java in that you need to explicitly state whether you are passing something by value or by reference. You can also define when a variable will behave as if it contains actual data and when a variable will only contain a pointer to data. You can even make an int that behaves like the Test class did above. This is all done with the &amp; (referencing) and * (dereferencing) symbols.</p>
<p>the &amp; symbol is used to acquire the memory address of a variable or function, so for example:</p>
<pre><code class="cpp">    b=1;
    a = &amp;b;
</code></pre>

<p>means, a is now equal to (or points to) the memory address of b, (and not the value of b). At this point, </p>
<pre><code class="cpp">    a++;
</code></pre>

<p>would make a equal to the next memory address after b.</p>
<p>the * symbol is used to acquire the value stored in an address. So, </p>
<pre><code class="cpp">    *a++;
</code></pre>

<p>would increment the value stored in a, and therefore, b would now equal 2.</p>
<p>But how do I declare a variable to point to an address?
To do this, you use the * symbol. This variable is called a pointer. Because different types of variables take on specific numbers of bytes, it is important to declare pointers of the same type as what they are pointing to, e.g. integer pointers for integers, float pointers for floats, etc.</p>
<p>example:</p>
<pre><code class="cpp">    int x;
    int *ptr;

    x=5;
    ptr = &amp;x;
    *ptr = 10;

    //x now equals 10
</code></pre>

<h3>どんな状況で使うのか?</h3>
<p>Initially, you will use pointers to pass arrays back and forth through functions. This can be seen in the movieGrabberExample, where a pointer is used to access the pixels from the video grabber. </p>
<pre><code class="cpp">    ( unsigned char *   videoInverted;)
</code></pre>

<p>This works because when you refer to an array in C++ without the []'s you are actually referring to an address in memory. The []'s work as a dereferencing operator, or, a "*". </p>
<p>At runtime, your processor multiplies the number inside of the []'s (your index) by the number of bytes your data-type takes up in memory to figure out how far it must jump in memory to reach that index of your array.</p>
<p>So to pass an array in C++ you must pass it without the []'s, and the receiving function must be aware it is receiving a pointer:</p>
<pre><code>[functionName] ( [variable type] * [varName]){
}
</code></pre>
<p>To learn more about the infinite complexities of pointers, I recommend visiting the site I referenced at the top of this section.
( <a href="http://www.cplusplus.com/doc/tutorial/pointers.html" title="http://www.cplusplus.com/doc/tutorial/pointers.html">http://www.cplusplus.com/doc/tutorial/pointers.html</a> )</p>
<h3>基本のデータ型</h3>
<p>Java and C++ share most basic data-types:</p>
<p>byte, short, int, long, float, double, and char. 
(Boolean is also in C++, and works the same way as it does in processing except it is called 'bool').</p>
<p>However, C++ has an extra set of data-types that are unsigned:</p>
<p>unsigned byte, unsigned short, unsigned int, unsigned long, unsigned float, unsigned double, unsigned char.</p>
<p>Unsigned means that instead of running positive and negative, (e.g. char can be set to any value between -128 and 127), these variables have no sign. (e.g. unsigned char can be set to any value 0-255).</p>
<h4>Processingの文字列の例外</h4>
<p>One major difference in the basic data-types is that Processing's string type is "String" while C++ uses a lowercase "string". But more importantly, C++'s string type, when set equal to another string type refers to it by reference (does not make a copy).</p>
<p>_<strong>NOTE: (theo) not sure if this is true. I think C++ is by copy. So this example might be incorrect.</strong> _</p>
<p>_<strong>NOTE: (nathan) I've tested this. It's definitely incorrect. Output is "yes". Also it should be a.c_str() not a.c_str(a)</strong> _</p>
<p>So, in processing:</p>
<pre><code class="java">    String a = &quot;yes&quot;;
    String b = a;
    b = &quot;no&quot;;

    print(a);
</code></pre>

<p>will print "yes"</p>
<p>but in C++</p>
<pre><code class="cpp">    string a = &quot;yes&quot;;
    string b = a;
    b = &quot;no&quot;;
    printf(&quot;%s \n&quot;, a.c_str(a));   // to see how this prints, see section 6.3.3 How in the world do I print to the console?
</code></pre>

<p>will print "no".</p>
<h2>PImage, updatePixels() 対 ofTexture, pixels[]</h2>
<p>When you draw in openGL (OF draws using the GLUT library, which in turn uses openGL, Processing draws to openGL optionally, if you decide to when declaring your window size), any pixel data that you want to put on the screen must be preloaded into your RAM before you can draw it. Loading pixel (bitmap) data to RAM is called loading your image into a texture.</p>
<p>Processing has a number of ways to solve this texture problem that hide what you are actually doing from you.</p>
<p>The first is the PImage object. A PImage is a texture object that has a built in color array that holds pixel values so that you can access the individual pixels of the image that you have loaded in. Images cannot draw themselves exactly, but they can be drawn by the image() function.</p>
<pre><code class="java">    PImage myPImage; //allocate space for variable
    myPImage = loadImage(&quot;sample.jpg&quot;); //allocate space for pixels in ram, decode the jpg, and load pixels of the decoded sample.jpg into the pixels.
    image(myPImage,100,100); //draw the texture to the screen at 100,100
</code></pre>

<p><em>I should note that its possible that the image() function actually loads the pixels into the ram instead of the PImage, but I dont know enough about the tech behind Processing to say for sure if this is the case or not.</em></p>
<p>If you want to access the individual pixels of the screen itself, however, you use a different function altogether. You first call loadPixels(), make your pixel changes, and then call updatePixels() to make your changes appear. </p>
<p>This is slightly confusing, because what is actually happening here is the same as what happened above with the PImage: Processing is loading your pixels from the screen into a texture, essentially a PImage, and then drawing that texture to the screen after you update it. For some reason, however, they chose not to use the same function for both.</p>
<p>OpenFrameworks handles this a little differently (and a little bit better in my opinion). Instead of having two different methods, the ofImage object loads images from files, <em>and</em> images from the screen. Additionally, ofImage can draw itself and needs no separate function to do this.</p>
<p>The OF code for the example above with myPImage looks like:</p>
<pre><code class="cpp">    ofImage myImage; //allocate space for variable
    myImage.loadImage(&quot;sample.jpg&quot;); //allocate space in ram, decode jpg, load pixels.
    myImage.draw(100,100);
</code></pre>

<p>If you wanted to change the pixels on the screen, you would also use an ofImage.</p>
<pre><code class="cpp">    ofImage theScreen; //declare variable
    theScreen.grabScreen(0,0,1024,768); //grab at 0,0 a rect of 1024x768. Equivalent to loadPixels();
    //edit pixels in theScreen
    theScreen.draw(0,0); //equivalent to updatePixels();
</code></pre>

<p>But how do I edit the pixels of something that is in the ram you may ask? The short answer is you cannot. Once something is in the RAM (in an ofTexture), you cannot access it anymore. </p>
<p>You can edit the pixels of an ofImage because ofImages contain two data structures. One of these is an array of Unsigned Characters which represent all of the colors of every pixel, and the other is an ofTexture, which is used to upload those pixels into the ram after changes.</p>
<p>You can actually turn off this texture in an ofImage to save RAM if you know you won't ever have to draw what you are loading to the screen. This could be useful if you only need to load an image to access pixel color values in it, or if you are taking a screenshot that you will save to your hard drive but never draw. 
see: <a href="http://www.openframeworks.cc/documentation#ofImage-setUseTexture" title="http://www.openframeworks.cc/documentation#ofImage-setUseTexture">http://www.openframeworks.cc/documentation#ofImage-setUseTexture</a></p>
<h3>何故Pixelの値はColorオブジェクトとして格納されていないの?</h3>
<p>Pixel values are stored as a series of Unsigned Characters. An Unsigned Character is a fancy way of saying a byte value between 0 and 255 inclusive. Every object in OF that can return a pixel array ( getPixels() ), will return you an array of unsigned characters. Because it takes three unsigned characters to denote a color (one for each of the red, green, blue, channels), this array's length will be three times the number of pixels inside of it and structured like:</p>
<pre><code class="cpp">    {pixel_1_Red, pixel_1_Green, pixel_1_Blue, pixel_2_Red, pixel_2_Green, pixel_2_Blue....}
</code></pre>

<p>To access a color of a specific pixel:</p>
<pre><code class="cpp">    unsigned char * myPixels; //create a pointer to an unsigned charecter
    myPixels = myOFImage.getPixels(); //set that pointer to point to the beginning of the pixel array
    int colorIndex = y*(myOFImage.width*3)+x*3; // yPos * width * 3 + xPos * 3 = the red channel position
    ofSetColor(myPixels[colorIndex],myPixels[colorIndex+1],myPixels[colorIndex+2]); 
    //sets the color of each channel by going to the successive two values in the array after that of the red channel. 
</code></pre>

<h2>C++に関する既知の問題 / その他のトピックス</h2>
<h3>暗黙のデータ変換の期待</h3>
<p>One big surprise that comes with C++ is that it doesn't do implicit data conversion.
A good example of this is trying to print an integer.</p>
<pre><code class="cpp">    int num = 5;
    printf(num +&quot;\n&quot;);
</code></pre>

<p>will yield an error.</p>
<p>This is because printf only prints strings and chars, and num is neither one of these.
To convert any non-string or non-char to a string, use the ofToString() function.</p>
<h3>ウィンドウのサイズ変更</h3>
<p>Window size is set intuitively in main.cpp. If you open it up, the comments will show you clearly how to change the size or go to fullscreen mode.</p>
<h3>Update()とDraw()?</h3>
<p>Unlike Processing, OF contains two methods that are run every loop through of your program, Update() and Draw(). 
It is good practice to do all of your calculations in the Update() function and reserve Draw() for simply showing results on the screen. This prevents any large slowdowns that might occur during a draw function that could be too complicated. Instead of getting halves of images drawn or screen-tearing, you simply get a low framerate.</p>
<p>Additionally, I should mention that if you do any heavy lifting in your project (e.g. loading in images, or loading anything at all from a file really), you should do it in your setup() function if possible. Update() and Draw() run in a loop, and because of that you should only include code in them that has to run every frame. If something only has to run once, it should probably be in Setup().</p>
<h3>コンソールに出力するには?</h3>
<p>For printing to the console, you have two options. The first is printf, which is robust but a bit complicated, and is included by default in openframeworks.</p>
<p>The second is iostream, which is simpler, but less robust, and not included by default.</p>
<h4>printf</h4>
<p>If you want to use printf to print to the console, this is a good tutorial on how it works:
<a href="http://www.cplusplus.com/reference/clibrary/cstdio/printf.html" title="http://www.cplusplus.com/reference/clibrary/cstdio/printf.html">http://www.cplusplus.com/reference/clibrary/cstdio/printf.html</a></p>
<h4>iostream</h4>
<p>Another option for printing to the console is iostream. This is a very old c++ library that lets you print to the console very easily and will implicitly convert many variable types for you so you don't have to use ofToString(). </p>
<p>To use iostream you first need to include it at the top of your .cpp file</p>
<pre><code class="cpp">    #include &lt;iostream&gt;
</code></pre>

<p>Note that in some compilers, specifically very old ones, you will need to include &lt;iostream.h> instead of just &lt;iostream>. This is due to updates in the c++ standard language library (std) in recent years. A more detailed explanation can be found at:</p>
<p><a href="http://members.gamedev.net/sicrane/articles/iostream.html" title="http://members.gamedev.net/sicrane/articles/iostream.html">http://members.gamedev.net/sicrane/articles/iostream.html</a></p>
<p>Actually using iostream is extraordinarily easy.</p>
<p>in processing your code might look like this:</p>
<pre><code class="java">    int i = 10;
    String s = &quot;Hello!&quot;;
    boolean b = false;

    println(i+&quot; &quot;+s+&quot; &quot;+b); // print variables and end the line
    print(i+&quot; &quot;+s+&quot; &quot;+b); // print variables without ending the line.
</code></pre>

<p>this would print </p>
<pre><code class="java">    10 Hello! false
    10 Hello! false
</code></pre>

<p>in the console.</p>
<p>The equivalent c++ code using iostream is:</p>
<pre><code class="cpp">    int i = 10;
    string s = &quot;Hello!&quot;;
    bool b = false;

    cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; // print variables and end the line
    cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;b;       // print variables without ending the line.
</code></pre>

<p>this would print </p>
<pre><code class="cpp">    10 Hello! 0
    10 Hello! 0
</code></pre>

<p>in the console. Note that with iostream, unlike in processing, a false boolean is represented by a '0' and not "false", and a true boolean is represented by a '1'.</p>
<p>Also note that in Java, ending or not ending the line after you print is accomplished by which function you pick, print() or println(), whereas in c++ with iostream, it is controlled by whether or not you put the 'endl' keyword at the end of your cout statement.</p>
<h3>塗り潰しの図形は、スムージングできない?</h3>
<p>If you are drawing a filled shape, e.g. with ofBeginShape(), even if you have called ofEnableSmoothing(), you will notice that the edges of the shape have not been smoothed. This is because GLUT, the library that OF uses for openGL management, doesn't have support for true full-screen graphics, and therefor can't run full-screen anti-aliasing, which is what would smooth your shapes.</p>
<p>An easy workaround for this is to simply draw your shapes twice, the first time filled, and the second time not filled, so that OF draws lines, which it software anti-aliases.</p>
<pre><code class="cpp">    ofFill();

    ofBeginShape(); //shape
        ofVertex( 1,1 );
        ofVertex( 5,5 );
        ofVertex( 1,10 );
        ofVertex( 1,1 );
    ofEndShape();

    ofNoFill();

    ofBeginShape(); //smoothed edges
        ofVertex( 1,1 );
        ofVertex( 5,5 );
        ofVertex( 1,10 );
        ofVertex( 1,1 );
    ofEndShape();
</code></pre>

<h3>ofSetColorに関するビデオ表示の問題</h3>
<p>Although this is a problem/feature affecting any object that uses an ofTexture draw itself to the screen, I first encountered it with the videoGrabber, and I think that may be the case for many people, so I'm listing it as the video problem/feature.</p>
<p>Basically, ofTextures are constructed so that they can be tinted by the ofSetColor() call. This is great as long as you know it's going to happen, but if it catches you by surprise it can be really confusing, especially if your background is black and you have just called </p>
<pre><code class="cpp">    ofSetColor(0,0,0);
</code></pre>

<p>which would make whatever ofTexture you're telling to draw not show up at all.</p>
<p>The solution to this is easy, just make sure that right before you tell any ofTextures to draw, you call ofSetColor() and set it to white, or whatever tint you want to use.</p>
<h3>Processingのbackground() 対 oFのofBackground()</h3>
<p>In Processing, making the background() call automatically tells Processing to set the background to be set every frame to the color you specified in your function call.</p>
<p>Of can make it auto-refresh every frame, there is a separate function to call:</p>
<pre><code class="cpp">    ofSetBackgroundAuto(true);
</code></pre>

<p>This function will make the background autorefresh with the last ofBackground() call, without having to re-call it each time inside draw().
If you don't want to redraw, but make a cumulative image, use:</p>
<pre><code class="cpp">    ofSetBackgroundAuto(false);
</code></pre>

<p>Because by default OF redraws the screen every frame.</p>
<h3>ofFill() / ofNoFill() 対 Processingのfill() noFill()</h3>
<p>In processing, you can toggle fills and strokes:
fill(), noFill.
stroke(), noStroke.</p>
<p>In Openframeworks, it's one or the other.
C++  :
JAVA/P5:</p>
<p>ofFill();
fill(); noStroke();</p>
<p>ofNoFill();
noFill(); stroke(1);</p>
<p>additionally, there is no way to change the stroke width built into openFrameworks.
A way around this is to change the stroke size with an openGL call, but it doesn't look that great.</p>
<pre><code class="cpp">    glLineWidth(STROKE_SIZE);
</code></pre>

<h3>数学関数とそれはどこから来たのか?(ノー・モア Math.*)</h3>
<p>Math functions in OpenFrameworks actually come from three separate files</p>
<h4>cmath</h4>
<p>Complex math functions (trigonometric, hyperbolic, exponential, logarithmic, power, rounding, absolute value and remainder functions) come from the cmath library (math.h), and are included by default in OF.</p>
<p>A list of these functions is available at:
<a href="http://www.cplusplus.com/reference/clibrary/cmath/" title="http://www.cplusplus.com/reference/clibrary/cmath/">http://www.cplusplus.com/reference/clibrary/cmath/</a></p>
<h4>ofConstants</h4>
<p>Other basic math functions are provided by the ofConstants file.</p>
<p>These include:</p>
<p>Constants:</p>
<ul>
<li>PI;</li>
<li>TWO_PI;</li>
<li>M_TWO_PI;</li>
<li>FOUR_PI;</li>
<li>HALF_PI;</li>
</ul>
<p>and Functions:</p>
<ul>
<li>DEG_TO_RAD();</li>
<li>RAD_TO_DEG();</li>
<li>MIN(x,y);</li>
<li>MAX(x,y);</li>
<li>CLAMP(val,min,max);</li>
<li>ABS([math functions you want to get the absolute value of]);</li>
</ul>
<h4>ofMath</h4>
<p>additionally ofMath() provides functions for getting random values.</p>
<p><a href="http://www.openframeworks.cc/documentation#ofMath-about" title="http://www.openframeworks.cc/documentation#ofMath-about">http://www.openframeworks.cc/documentation#ofMath-about</a></p>
<h3>構造体、何のために、どうやって使うのか?</h3>
<p>Structs are like miniature classes except they don't have methods. Basically they're custom data objects.</p>
<p>They're very convenient because they don't have to be created externally from your class files (although technically neither do classes..) </p>
<p>Primarily they're used for implementing linked lists (similar to ArrayLists in java). Although linked lists are probably my favorite data structure, I'm not going to write a tutorial here because they can be very complicated at first.</p>
<p>A very inclusive tutorial on linked lists can be found here:
<a href="http://richardbowles.tripod.com/cpp/linklist/linklist.htm" title="http://richardbowles.tripod.com/cpp/linklist/linklist.htm">http://richardbowles.tripod.com/cpp/linklist/linklist.htm</a></p>
<p>Anyway, the general format of a struct is :</p>
<pre><code>struct [name]
{
    [varType] varName;
    [varType] varName;
    [varType] varName;
    [etc...]
};
</code></pre>
<h3>メモリ管理</h3>
<p>In Java/p5 the way garbage collection works is that every few cycles the interpreter sweeps the ram looking for any used objects that have no pointers referencing them, and deletes them.</p>
<p>That means if you were to declare</p>
<pre><code class="cpp">    myCustomDataType temp = new myCustomDataType();
    temp = null;
</code></pre>

<p>temp was set to reference a newly created myCustomDataType. temp was then set equal to null. This did not actually clear the new myCustomDataType from ram, but whenever java's garbage collection runs it would notice that the new myCustomDataType has no references and would delete it. </p>
<p>Unlike java/p5 however, c++ does not have automated garbage collection. This means that if you have declared object and you want to get rid of it, you will have to delete it yourself. Setting a pointer to NULL is not good enough.</p>
<p>calling the comparable code in c++ would result in an empty pointer and some memory that had been allocated in the ram but now is lost forever. This is called a memory leak. Although it might not affect you right off the bat, memory leaks can lead to your program eating up all of its available memory and crashing. These can be very frustrating to debug because they happen over time and don't give you a specific line that's crashing your program. </p>
<p>Fortunately, they're easy to avoid as long as you plan your programs carefully. The proper way to delete an object after you have created it is to use the delete keyword</p>
<pre><code class="cpp">    delete temp;
</code></pre>

<h3>基本的な論理構造の問題</h3>
<p>Zach Lieberman asked me to include a bit on conditional logic errors so here goes.</p>
<p>A very common conditional logic error is forgetting to restate your entire argument inside an if statement with an &amp;&amp; (and) or || (or) operator.</p>
<p>For example:</p>
<pre><code class="cpp">    int x = 5;
    if(x &lt; 0 || &gt; 10)
    {
        return true;
    }
    else
    {
        return false;
    }
</code></pre>

<p>will always return true because ( > 10) is always true. The proper way to write this would be:</p>
<pre><code class="cpp">    int x = 5;

    if(x &lt; 0 ||x &gt; 10)
    {
        return true;
    }
    else
    {
        return false;
    }
</code></pre>

<p>note how the entire argument is restated. Instead of asking:
is x less than 0 or greater than 10</p>
<p>you need to ask:
is x less than 0 or <strong>is x</strong> greater than 10</p>
<h3>Xcodeのブレイクポイントと、何故デバッガが凄いのか</h3>
<p><a href="file:///index.php?title=Image:BkPt.jpg" title="Image:BkPt.jpg"><img alt="Image:BkPt.jpg" src="002_images/BkPt.jpg" /></a></p>
<p>Breakpoints are something that you can put in by clicking on the far left column of the editing window. If you're compiling in debug mode:
<a href="file:///index.php?title=Image:BuildConf.jpg" title="Image:BuildConf.jpg"><img alt="Image:BuildConf.jpg" src="002_images/BuildConf.jpg" /></a></p>
<p>your program will stop running whenever it comes across one of these breakpoints and bring up the debugging console which lets you look at variable contents and the current running processes and things like that. 
<a href="file:///index.php?title=Image:HilightedVar.jpg" title="Image:HilightedVar.jpg"><img alt="Image:HilightedVar.jpg" src="002_images/HilightedVar.jpg" /></a></p>
<p>They're extremely convenient for debugging programs, but they can be confusing if you don't know what they are and they keep stopping your program.</p>
<p>To remove a debug point just click on it and drag it out of the window. You'll get a friendly poof of smoke and it'll be gone.</p>

        		</div>
            </div><!-- End Page Wide -->
        
    	

    	</div>
              
      </div><!-- End Body Wrap -->
      
      <div id="footer">
        
  <p id="credits">

Last updated 
  
Friday, 24 February 2012 05:11:02 UTC
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/openframeworks/ofSite/commit/

45a261bdf35a3d1c2c19d8f62f418dc3ffb7ce12
">

45a261bdf35a3d1c2c19d8f62f418dc3ffb7ce12
</a>

<!--br/>RSS feeds for <a href="/blog/feed">Entries</a-->

<br/>

</p>




<!--tracking -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-9614675-1");
pageTracker._trackPageview();
} catch(err) {}</script>








      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>







